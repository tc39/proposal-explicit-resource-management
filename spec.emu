<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<link rel="spec" href="es2015" />
<style>
  h1.ins {
    background-color: #e0f8e0;
    text-decoration: none;
    border-bottom: 1px solid #396;
  }
  hr {
    height: 0.25em;
    background: #ccc;
    border: 0;
    margin: 2em 0;
  }
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }
  .unicode-property-table ul {
    padding-left: 0;
    list-style: none;
  }

</style>
<pre class="metadata">
title: ECMAScript Explicit Resource Management
status: proposal
stage: 2
contributors: Ron Buckton, Ecma International
</pre>

<emu-biblio href="node_modules/@tc39/ecma262-biblio/biblio.json"></emu-biblio>

<emu-intro id="intro">
  <h1>Introduction</h1>
  <p>This proposal introduces syntax and semantics around explicit resource management.</p>
  <p>See <a href="https://github.com/tc39/explicit-resource-management">the proposal repository</a> for background material and discussion.</p>
</emu-intro>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>
    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>The Symbol Type</h1>
      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>@@asyncDispose</ins>
              </td>
              <td>
                <ins>`"Symbol.asyncDispose"`</ins>
              </td>
              <td>
                <ins>A method that performs explicit resource cleanup on an object. Called by the semantics of AsyncDisposableStack objects.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>@@dispose</ins>
              </td>
              <td>
                <ins>`"Symbol.dispose"`</ins>
              </td>
              <td>
                <ins>A method that performs explicit resource cleanup on an object. Called by the semantics of the `using` declaration and DisposableStack objects.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>Well-Known Intrinsic Objects</h1>
        <emu-table id="table-well-known-intrinsic-objects" caption="Well-Known Intrinsic Objects" oldids="table-7">
          <table>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                The `AggregateError` constructor (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                The Array constructor (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                The ArrayBuffer constructor (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Array iterator objects (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%AsyncDisposableStack%</ins>
              </td>
              <td>
                <ins>`AsyncDisposableStack`</ins>
              </td>
              <td>
                <ins>The AsyncDisposableStack constructor (<emu-xref href="#sec-asyncdisposablestack-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async-from-sync iterator objects (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async function objects (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async iterator objects (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                The `Atomics` object (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                The BigInt constructor (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                The BigInt64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                The BigUint64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                The Boolean constructor (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                The DataView constructor (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                The Date constructor (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                The `decodeURI` function (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                The `decodeURIComponent` function (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%DisposableStack%</ins>
              </td>
              <td>
                <ins>`DisposableStack`</ins>
              </td>
              <td>
                <ins>The DisposableStack constructor (<emu-xref href="#sec-disposablestack-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                The `encodeURI` function (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                The `encodeURIComponent` function (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                The Error constructor (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                The `eval` function (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                The EvalError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                The FinalizationRegistry constructor (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                The Float32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                The Float64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of For-In iterator objects (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                The Function constructor (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of Generators (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                The Int8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                The Int16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                The Int32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                The `isFinite` function (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                The `isNaN` function (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                The `JSON` object (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                The Map constructor (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Map iterator objects (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                The `Math` object (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                The Number constructor (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                The Object constructor (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                The `parseFloat` function (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                The `parseInt` function (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                The Promise constructor (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                The Proxy constructor (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                The RangeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                The ReferenceError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                The `Reflect` object (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                The RegExp constructor (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of RegExp String Iterator objects (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                The Set constructor (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Set iterator objects (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                The SharedArrayBuffer constructor (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                The String constructor (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of String iterator objects (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                The Symbol constructor (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                The SyntaxError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                A function object that unconditionally throws a new instance of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                The super class of all typed Array constructors (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                The TypeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                The Uint8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                The Uint8ClampedArray constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                The Uint16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                The Uint32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                The URIError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                The WeakMap constructor (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                The WeakRef constructor (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                The WeakSet constructor (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>The Reference Record Specification Type</h1>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: unknown,
            _W_: unknown,
            <ins>_hint_: either ~normal~ or ~sync-dispose~,</ins>
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ReturnIfAbrupt(_V_).
          1. ReturnIfAbrupt(_W_).
          1. Assert: _V_ is a Reference Record.
          1. Assert: IsUnresolvableReference(_V_) is *false*.
          1. Let _base_ be _V_.[[Base]].
          1. Assert: _base_ is an Environment Record.
          1. Return ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_<ins>, _hint_</ins>).
        </emu-alg>
      </emu-clause>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>

  <ins class="block">
  <emu-clause id="sec-operations-on-disposable-objects">
    <h1>Operations on Disposable Objects</h1>
    <p>See Common Resource Management Interfaces (<emu-xref href="#sec-common-resource-management-interfaces"></emu-xref>).</p>
    <emu-clause id="sec-disposableresource-records">
      <h1>DisposableResource Records</h1>
      <p>A <dfn variants="DisposableResource Records">DisposableResource Record</dfn> is a Record value used to encapsulate a disposable object along with the method used to dispose the object. DisposableResource Records are produced by the CreateDisposableResource abstract operation.</p>
      <p>DisposableResource Records have the fields listed in <emu-xref href="#table-disposableresource-record-fields"></emu-xref>:</p>
      <emu-table id="table-disposableresource-record-fields" caption="DisposableResource Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[ResourceValue]]
            </td>
            <td>
              An Object or *undefined*.
            </td>
            <td>
              The value to be disposed.
            </td>
          </tr>
          <tr>
            <td>
              [[Hint]]
            </td>
            <td>
              ~sync-dispose~ or ~async-dispose~.
            </td>
            <td>
              Indicates whether the resources was added by a `using` declaration or DisposableStack object (~sync-dispose~) or an AsyncDisposableStack object (~async-dispose~).
            </td>
          </tr>
          <tr>
            <td>
              [[DisposeMethod]]
            </td>
            <td>
              A function object.
            </td>
            <td>
              A function object that will be called with [[ResourceValue]] as its *this* value when the resource disposed.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-adddisposableresource-disposable-v-hint-disposemethod" type="abstract operation">
      <h1>
        AddDisposableResource (
          _disposable_ : an object with a [[DisposableResourceStack]] internal slot,
          _V_ : an ECMAScript language value,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          optional _method_ : a function object,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _method_ is not present then,
          1. If _V_ is *null* or *undefined*, return NormalCompletion(~empty~).
          1. If Type(_V_) is not Object, throw a *TypeError* exception.
          1. Let _resource_ be ? CreateDisposableResource(_V_, _hint_).
        1. Else,
          1. If _V_ is *null* or *undefined*, then
            1. Let _resource_ be ? CreateDisposableResource(*undefined*, _hint_, _method_).
          1. Else,
            1. If Type(_V_) is not Object, throw a *TypeError* exception.
            1. Let _resource_ be ? CreateDisposableResource(_V_, _hint_, _method_).
        1. Append _resource_ to _disposable_.[[DisposableResourceStack]].
        1. Return NormalCompletion(~empty~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdisposableresource" type="abstract operation">
      <h1>
        CreateDisposableResource (
          _V_ : an Object or *undefined*,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          optional _method_ : a function object,
        )
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _method_ is not present, then
          1. If _V_ is *undefined*, throw a *TypeError* exception.
          1. Set _method_ to ? GetDisposeMethod(_V_, _hint_).
          1. If _method_ is *undefined*, throw a *TypeError* exception.
        1. Else,
          1. If IsCallable(_method_) is *false*, throw a *TypeError* exception.
        1. Return the DisposableResource Record { [[ResourceValue]]: _V_, [[Hint]]: _hint_, [[DisposeMethod]]: _method_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getdisposemethod" type="abstract operation">
      <h1>
        GetDisposeMethod (
          _V_ : an Object,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
        )
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _hint_ is ~async-dispose~, then
          1. Let _method_ be ? GetMethod(_V_, @@asyncDispose).
          1. If _method_ is *undefined*, then
            1. Set _method_ to ? GetMethod(_V_, @@dispose).
        1. Else,
          1. Let _method_ be ? GetMethod(_V_, @@dispose).
        1. Return _method_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-dispose" type="abstract operation">
      <h1>
        Dispose (
          _V_ : an Object or *undefined*,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          _method_ : a function object,
        )
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _result_ be ? Call(_method_, _V_).
        1. If _hint_ is ~async-dispose~ and _result_ is not *undefined*, then
          1. Perform ? Await(_result_).
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-disposeresources-disposable-completion-errors" type="abstract operation">
      <h1>
        DisposeResources (
          _disposable_ : an object with a [[DisposableResourceStack]] internal slot or *undefined*,
          _completion_ : a Completion Record
        ): a Completion Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _disposable_ is not *undefined*, then
          1. For each _resource_ of _disposable_.[[DisposableResourceStack]], in reverse list order, do
            1. Let _result_ be Dispose(_resource_.[[ResourceValue]], _resource_.[[Hint]], _resource_.[[DisposeMethod]]).
              1. If _result_.[[Type]] is ~throw~, then
                1. Let _disposeError_ be a newly created *AggregateError* object.
                1. Let _errors_ be ! CreateArrayFromList( &laquo; _result_.[[Value]] &raquo; ).
                1. Perform ! DefinePropertyOrThrow(_disposeError_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: _errors_ }).
                1. If _completion_.[[Type]] is ~throw~, then
                  1. Perform ! CreateNonEnumerableDataPropertyOrThrow(_disposeError_, "cause", _completion_.[[Value]]).
                1. Set _completion_ to ThrowCompletion(_disposeError_).
        1. Return _completion_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>Syntax-Directed Operations</h1>
  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>Scope Analysis</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>Static Semantics: BoundNames ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* is used within this specification as a synthetic name for a module's default export when it does not have another name. An entry in the module's [[Environment]] is created with that name and holds the corresponding value, and resolving the export named *"default"* by calling <emu-xref href="#sec-resolveexport" title></emu-xref> for the module will return a ResolvedBinding Record whose [[BindingName]] is *"\*default\*"*, which will then resolve in the module's [[Environment]] to the above-mentioned value. This is done only for ease of specification, so that anonymous default exports can be resolved like any other export. The string *"\*default\*"* is never accessible to user code or to the module linking algorithm.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is the StringValue of |Identifier|.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"yield"* &raquo;.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"await"* &raquo;.
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      <ins class="block">
      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      </ins>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |BindingList|.
        1. Let _names2_ be the BoundNames of |LexicalBinding|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |VariableDeclarationList|.
        1. Let _names2_ be BoundNames of |VariableDeclaration|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingRestProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingRestElement|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElementList|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingRestElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingElisionElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. Return BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ForBinding|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FunctionRestParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FormalParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return the BoundNames of _formals_.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Return the BoundNames of _head_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportClause|.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NameSpaceImport|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NamedImports|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportsList|.
        1. Let _names2_ be the BoundNames of |ImportSpecifier|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportedBinding|.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |VariableStatement|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |Declaration|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. Return &laquo; *"\*default\*"* &raquo;.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>Static Semantics: IsConstantDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return IsConstantDeclaration of |LetOrConst|.
      </emu-alg>
      <ins class="block">
      <emu-grammar>LexicalDeclaration : UsingDeclaration</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      </ins>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>It is not necessary to treat `export default` |AssignmentExpression| as a constant declaration because there is no syntax that permits assignment to the internal bound name used to reference a module's default object.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        Runtime Semantics: IteratorBindingInitialization (
          _iteratorRecord_: unknown,
          _environment_: unknown,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_next_).
          1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Else,
            1. Set _v_ to Completion(IteratorValue(_next_)).
            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_v_).
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _defaultValue_ be the result of evaluating |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
        1. Return ? InitializeReferencedBinding(_lhs_, _v_<ins>, ~normal~</ins>).
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_next_).
          1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. Else,
            1. Set _v_ to Completion(IteratorValue(_next_)).
            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_v_).
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. Let _defaultValue_ be the result of evaluating |Initializer|.
          1. Set _v_ to ? GetValue(_defaultValue_).
        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. If _iteratorRecord_.[[Done]] is *true*, then
            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).
            1. Return ? InitializeReferencedBinding(_lhs_, _A_<ins>, ~normal~</ins>).
          1. Let _nextValue_ be Completion(IteratorValue(_next_)).
          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_nextValue_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. If _iteratorRecord_.[[Done]] is *true*, then
            1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.
          1. Let _nextValue_ be Completion(IteratorValue(_next_)).
          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_nextValue_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Set _v_ to Completion(IteratorValue(_next_)).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Set _v_ to Completion(IteratorValue(_next_)).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>
  <emu-clause id="sec-environment-records">
    <h1>Environment Records</h1>
    <p><dfn>Environment Record</dfn> is a specification type used to define the association of |Identifier|s to specific variables and functions, based upon the lexical nesting structure of ECMAScript code. Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a |FunctionDeclaration|, a |BlockStatement|, or a |Catch| clause of a |TryStatement|. Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.</p>
    <p>Every Environment Record has an [[OuterEnv]] field, which is either *null* or a reference to an outer Environment Record. This is used to model the logical nesting of Environment Record values. The outer reference of an (inner) Environment Record is a reference to the Environment Record that logically surrounds the inner Environment Record. An outer Environment Record may, of course, have its own outer Environment Record. An Environment Record may serve as the outer environment for multiple inner Environment Records. For example, if a |FunctionDeclaration| contains two nested |FunctionDeclaration|s then the Environment Records of each of the nested functions will have as their outer Environment Record the Environment Record of the current evaluation of the surrounding function.</p>
    <p>Environment Records are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>The Environment Record Type Hierarchy</h1>
      <p>The Environment Record abstract class includes the abstract specification methods defined in <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Abstract Methods of Environment Records" oldids="table-15">
        <table>
          <tbody>
          <tr>
            <th>
              Method
            </th>
            <th>
              Purpose
            </th>
          </tr>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Determine if an Environment Record has a binding for the String value _N_. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Create a new but uninitialized mutable binding in an Environment Record. The String value _N_ is the text of the bound name. If the Boolean argument _D_ is *true* the binding may be subsequently deleted.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Create a new but uninitialized immutable binding in an Environment Record. The String value _N_ is the text of the bound name. If _S_ is *true* then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V<ins>, _hint_</ins>)
            </td>
            <td>
              Set the value of an already existing but uninitialized binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type. <ins>_hint_ indicates whether the binding came from either a `using` declaration (~sync-dispose~) or a regular variable declaration (~normal~).</ins>
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              Set the value of an already existing mutable binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is *true* and the binding cannot be set throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              Returns the value of an already existing binding from an Environment Record. The String value _N_ is the text of the bound name. _S_ is used to identify references originating in strict mode code or that otherwise require strict mode reference semantics. If _S_ is *true* and the binding does not exist throw a *ReferenceError* exception. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              Delete a binding from an Environment Record. The String value _N_ is the text of the bound name. If a binding for _N_ exists, remove the binding and return *true*. If the binding exists but cannot be removed return *false*. If the binding does not exist return *true*.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `this` binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `super` method binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              If this Environment Record is associated with a `with` statement, return the with object. Otherwise, return *undefined*.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Records</h1>
        <p>Each <dfn>declarative Environment Record</dfn> is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.</p>
        <p><ins>Every declarative Environment Record also has a [[DisposableResourceStack]] field, which is a List of DisposableResource Records. This list is a stack of resources tracked by the `using` declarations that must be disposed when the Evaluation step that constructed the Environment Record has completed.</ins></p>
        <p>The behaviour of the concrete specification methods for declarative Environment Records is defined by the following algorithms.</p>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: either ~normal~ or ~sync-dispose~,</ins>
            ): a normal completion containing ~unused~
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</dd>
          </dl>
          <emu-alg>
            1. Assert: _envRec_ must have an uninitialized binding for _N_.
            1. <ins>If _hint_ is not ~normal~, perform ? AddDisposableResource(_envRec_, _V_, _hint_).</ins>
            1. Set the bound value for _N_ in _envRec_ to _V_.
            1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Records</h1>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: either ~normal~ or ~sync-dispose~,</ins>
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_.</dd>
          </dl>
          <emu-alg>
            1. <ins>Assert: _hint_ is ~normal~.</ins>
            1. Perform ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*).
            1. Return ~unused~.
          </emu-alg>
          <emu-note>
            <p>In this specification, all uses of CreateMutableBinding for object Environment Records are immediately followed by a call to InitializeBinding for the same name. Hence, this specification does not explicitly track the initialization state of bindings in object Environment Records.</p>
          </emu-note>
        </emu-clause>

      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>Global Environment Records</h1>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: either ~normal~ or ~sync-dispose~,</ins>
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</dd>
          </dl>
          <emu-alg>
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If ! _DclRec_.HasBinding(_N_) is *true*, then
              1. Return ! _DclRec_.InitializeBinding(_N_, _V_<ins>, _hint_</ins>).
            1. Assert: If the binding exists, it must be in the object Environment Record.
            1. <ins>Assert: _hint_ is ~normal~.</ins>
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_<ins>, ~normal~</ins>).
          </emu-alg>
        </emu-clause>

      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>
  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>
    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: a function object,
          _argumentsList_: unknown,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ is the function object for which the execution context is being established.</dd>
      </dl>
      <emu-note>
        <p>When an execution context is established for evaluating an ECMAScript function a new function Environment Record is created and bindings for each formal parameter are instantiated in that Environment Record. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-functiondeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _calleeContext_ be the running execution context.
        1. Let _code_ be _func_.[[ECMAScriptCode]].
        1. Let _strict_ be _func_.[[Strict]].
        1. Let _formals_ be _func_.[[FormalParameters]].
        1. Let _parameterNames_ be the BoundNames of _formals_.
        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.
        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.
        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.
        1. Let _varNames_ be the VarDeclaredNames of _code_.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.
        1. Let _functionNames_ be a new empty List.
        1. Let _functionsToInitialize_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _fn_ is not an element of _functionNames_, then
              1. Insert _fn_ as the first element of _functionNames_.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _argumentsObjectNeeded_ be *true*.
        1. If _func_.[[ThisMode]] is ~lexical~, then
          1. NOTE: Arrow functions never have an arguments object.
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if *"arguments"* is an element of _parameterNames_, then
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if _hasParameterExpressions_ is *false*, then
          1. If *"arguments"* is an element of _functionNames_ or if *"arguments"* is an element of _lexicalNames_, then
            1. Set _argumentsObjectNeeded_ to *false*.
        1. If _strict_ is *true* or if _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.
          1. Let _env_ be the LexicalEnvironment of _calleeContext_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.
          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.
          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).
          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.
          1. Set the LexicalEnvironment of _calleeContext_ to _env_.
        1. For each String _paramName_ of _parameterNames_, do
          1. Let _alreadyDeclared_ be _env_.HasBinding(_paramName_).
          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
          1. If _alreadyDeclared_ is *false*, then
            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).
            1. If _hasDuplicates_ is *true*, then
              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*<ins>, ~normal~</ins>).
        1. If _argumentsObjectNeeded_ is *true*, then
          1. If _strict_ is *true* or if _simpleParameterList_ is *false*, then
            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).
          1. Else,
            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).
          1. If _strict_ is *true*, then
            1. Perform ! _env_.CreateImmutableBinding(*"arguments"*, *false*, *false*).
          1. Else,
            1. Perform ! _env_.CreateMutableBinding(*"arguments"*, *false*).
          1. Call _env_.InitializeBinding(*"arguments"*, _ao_<ins>, ~normal~</ins>).
          1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and &laquo; *"arguments"* &raquo;.
        1. Else,
          1. Let _parameterBindings_ be _parameterNames_.
        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).
        1. If _hasDuplicates_ is *true*, then
          1. Perform ? IteratorBindingInitialization of _formals_ with _iteratorRecord_ and *undefined* as arguments.
        1. Else,
          1. Perform ? IteratorBindingInitialization of _formals_ with _iteratorRecord_ and _env_ as arguments.
        1. If _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.
          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.
          1. For each element _n_ of _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).
              1. Call _env_.InitializeBinding(_n_, *undefined*<ins>, ~normal~</ins>).
          1. Let _varEnv_ be _env_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).
          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.
          1. Let _instantiatedVarNames_ be a new empty List.
          1. For each element _n_ of _varNames_, do
            1. If _n_ is not an element of _instantiatedVarNames_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).
              1. If _n_ is not an element of _parameterBindings_ or if _n_ is an element of _functionNames_, let _initialValue_ be *undefined*.
              1. Else,
                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).
              1. Call _varEnv_.InitializeBinding(_n_, _initialValue_<ins>, ~normal~</ins>).
              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
        1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-functiondeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. If _strict_ is *false*, then
          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).
          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
        1. Else, let _lexEnv_ be _varEnv_.
        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).
        1. Let _privateEnv_ be the PrivateEnvironment of _calleeContext_.
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
        1. Return NormalCompletion(~empty~).
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript Language: Statements and Declarations</h1>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <emu-clause id="sec-block-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _blockValue_ be the result of evaluating |StatementList|.
        1. <ins>Set _blockValue_ to DisposeResources(_blockEnv_, _blockValue_).</ins>
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _blockValue_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a declarative Environment Record,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ is the Parse Node corresponding to the body of the block. _env_ is the Environment Record in which bindings are to be created.</dd>
      </dl>
      <emu-note>
        <p>When a |Block| or |CaseBlock| is evaluated a new declarative Environment Record is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the Environment Record.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-blockdeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. For each element _d_ of _declarations_, do
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. [id="step-blockdeclarationinstantiation-createmutablebinding"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
          1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
            1. [id="step-blockdeclarationinstantiation-initializebinding"] Perform _env_.InitializeBinding(_fn_, _fo_<ins>, ~normal~</ins>). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>Declarations and the Variable Statement</h1>
    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let<del> and Const</del><ins>, Const, and Using</ins> Declarations</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await, <ins>~Using</ins>] `;`
          <ins>UsingDeclaration[?In, ?Yield, ?Await]</ins>

        LetOrConst :
          `let`
          `const`

        <ins>
        UsingDeclaration[In, Yield, Await] :
          `using` [no LineTerminator here] BindingList[?In, ?Yield, ?Await, +Using] `;`
        </ins>

        BindingList[In, Yield, Await, <ins>Using</ins>] :
          LexicalBinding[?In, ?Yield, ?Await, <ins>?Using</ins>]
          BindingList[?In, ?Yield, ?Await, <ins>?Using</ins>] `,` LexicalBinding[?In, ?Yield, ?Await, <ins>?Using</ins>]

        LexicalBinding[In, Yield, Await, <ins>Using</ins>] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          <del>BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</del>
          <ins>[~Using] BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</ins>
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <ins class="block">
        <emu-grammar>
          UsingDeclaration :
            `using` BindingList `;`
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains *"let"*.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if the goal symbol is |Script| and |LexicalDeclaration| is not contained, either directly or indirectly, within a |Block|, |CaseBlock|, |ForStatement|, |ForInOfStatement|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, |ClassStaticBlockBody|, or |ClassBody|.
          </li>
        </ul>
        <emu-note>
          Draft Note: This behavior is currently under discussion in <a href="https://github.com/tc39/proposal-explicit-resource-management/issues/66">#66</a>. The above boundaries have been chosen for the following reasons:
          <ul>
            <li>
              |Block|, |CaseBlock|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, |ClassStaticBlockBody|, and |ClassBody| each introduce an explicit block scope.
            </li>
            <li>
              |ForStatement| and |ForInOfStatement| both introduce an implicit block scope per iteration.
            </li>
          </ul>
        </emu-note>
        </ins>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of <del>evaluating |BindingList|</del><ins>BindingEvaluation of |BindingList| with parameter ~normal~</ins>.
          1. ReturnIfAbrupt(_next_).
          1. Return ~empty~.
        </emu-alg>

        <ins class="block">
        <emu-grammar>UsingDeclaration : `using` BindingList `;`</emu-grammar>
        <emu-alg>
          1. Let _next_ be BindingEvaluation of |BindingList| with parameter ~sync-dispose~.
          1. ReturnIfAbrupt(_next_).
          1. Return ~empty~.
        </emu-alg>
        </ins>

        <del class="block">
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Let _next_ be the result of evaluating |BindingList|.
          1. ReturnIfAbrupt(_next_).
          1. Return the result of evaluating |LexicalBinding|.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ResolveBinding(StringValue of |BindingIdentifier|).
          1. Perform ? InitializeReferencedBinding(_lhs_, *undefined*).
          1. Return ~empty~.
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be Completion(ResolveBinding(_bindingId_)).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be the result of evaluating |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Perform ? InitializeReferencedBinding(_lhs_, _value_).
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be the result of evaluating |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization for |BindingPattern| using _value_ and _env_ as the arguments.
        </emu-alg>
        </del>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-bindingevaluation" type="sdo">
        <h1>
          Runtime Semantics: BindingEvaluation (
            _hint_: either ~normal~ or ~sync-dispose~
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Perform ? BindingEvaluation of |BindingList| with parameter _hint_.
          1. Perform ? BindingEvaluation of |LexicalBinding| with parameter _hint_.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|).
          1. Return ? InitializeReferencedBinding(_lhs_, *undefined*, ~normal~).
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be the result of evaluating |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Return ? InitializeReferencedBinding(_lhs_, _value_, _hint_).
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _rhs_ be the result of evaluating |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.
        </emu-alg>
      </emu-clause>
      </ins>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>Destructuring Binding Patterns</h1>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: RestBindingInitialization (
            _value_: unknown,
            _environment_: unknown,
            _excludedNames_: unknown,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. If _environment_ is *undefined*, return PutValue(_lhs_, _restObj_).
          1. Return ? InitializeReferencedBinding(_lhs_, _restObj_<ins>, ~normal~</ins>).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: KeyedBindingInitialization (
            _value_: unknown,
            _environment_: unknown,
            _propertyName_: unknown,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be the result of evaluating |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to ? NamedEvaluation for |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be the result of evaluating |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return ? InitializeReferencedBinding(_lhs_, _v_<ins>, ~normal~</ins>).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>

    <emu-clause id="sec-for-statement">
      <h1>The `for` Statement</h1>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: ForLoopEvaluation (
            _labelSet_: unknown,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. If the first |Expression| is present, then
            1. Let _exprRef_ be the result of evaluating the first |Expression|.
            1. Perform ? GetValue(_exprRef_).
          1. Return ? ForBodyEvaluation(the second |Expression|, the third |Expression|, |Statement|, &laquo; &raquo;, _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _varDcl_ be the result of evaluating |VariableDeclarationList|.
          1. ReturnIfAbrupt(_varDcl_).
          1. Return ? ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, &laquo; &raquo;, _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).
          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.
          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.
          1. For each element _dn_ of _boundNames_, do
            1. If _isConst_ is *true*, then
              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).
          1. Set the running execution context's LexicalEnvironment to _loopEnv_.
          1. Let _forDcl_ be the result of evaluating |LexicalDeclaration|.
          1. If _forDcl_ is an abrupt completion, then
            1. <ins>Set _forDcl_ to DisposeResources(_loopEnv_, _forDcl_).</ins>
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. Return ? _forDcl_.
          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.
          1. Let _bodyResult_ be Completion(ForBodyEvaluation(the first |Expression|, the second |Expression|, |Statement|, _perIterationLets_, _labelSet_)).
          1. <ins>Set _bodyResult_ to DisposeResources(_loopEnv_, _bodyResult_).</ins>
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return ? _bodyResult_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: unknown,
            _increment_: unknown,
            _stmt_: unknown,
            _perIterationBindings_: unknown,
            _labelSet_: unknown,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. <del>Perform ? CreatePerIterationEnvironment(_perIterationBindings_).</del>
          1. <ins>Let _thisIterationEnv_ be ? CreatePerIterationEnvironment(_perIterationBindings_).</ins>
          1. Repeat,
            1. If _test_ is not ~[empty]~, then
              1. Let _testRef_ be the result of evaluating _test_.
              1. <del>Let _testValue_ be ? GetValue(_testRef_).</del>
              1. <ins>Let _testValue_ be Completion(GetValue(_testRef_)).</ins>
              1. <ins>If _testValue_ is an abrupt completion, then</ins>
                1. <ins>Return ? DisposeResources(_thisIterationEnv_, _testValue_).</ins>
              1. <ins>Else,</ins>
                1. <ins>Set _testValue_ to _testValue_.[[Value]].</ins>
              1. <del>If ToBoolean(_testValue_) is *false*, return _V_.</del>
              1. <ins>If ToBoolean(_testValue_) is *false*, return ? DisposeResources(_thisIterationEnv_, Completion(_V_)).</ins>
            1. Let _result_ be the result of evaluating _stmt_.
            1. <ins>Perform ? DisposeResources(_thisIterationEnv_, _result_).</ins>
            1. If LoopContinues(_result_, _labelSet_) is *false*, return ? UpdateEmpty(_result_, _V_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
            1. <del>Perform ? CreatePerIterationEnvironment(_perIterationBindings_).</del>
            1. <ins>Set _thisIterationEnv_ to ? CreatePerIterationEnvironment(_perIterationBindings_).</ins>
            1. If _increment_ is not ~[empty]~, then
              1. Let _incRef_ be the result of evaluating _increment_.
              1. <del>Perform ? GetValue(_incRef_).</del>
              1. <ins>Let _incrResult_ be Completion(GetValue(_incrRef_)).</ins>
              1. <ins>If _incrResult_ is an abrupt completion, then</ins>
                1. <ins>Return ? DisposeResources(_thisIterationEnv_, _incrResult_).</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: unknown,
          ): either a normal completion containing either a Declarative Environment Record or ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _perIterationBindings_ has any elements, then
            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.
            1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].
            1. Assert: _outer_ is not *null*.
            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).
            1. For each element _bn_ of _perIterationBindings_, do
              1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).
              1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).
              1. Perform _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_<ins>, ~normal~</ins>).
            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.
            1. <ins>Return _thisIterationEnv_.</ins>
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>The `for-in`, `for-of`, and `for-await-of` Statements</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await, <ins>~Using</ins>] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await, <ins>~Using</ins>] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; {`let`, `async` `of`}] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await, <ins>~Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await, <ins>+Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await, <ins>~Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await, <ins>+Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await, <ins>Using</ins>] :
          LetOrConst ForBinding[?Yield, ?Await, <ins>~Using</ins>]
          <ins>[+Using] `using` [no LineTerminator here] ForBinding[?Yield, ?Await, +Using]</ins>

        ForBinding[Yield, Await, <ins>Using</ins>] :
          BindingIdentifier[?Yield, ?Await]
          <del>BindingPattern[?Yield, ?Await]</del>
          <ins>[~Using] BindingPattern[?Yield, ?Await]</ins>
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          Runtime Semantics: ForDeclarationBindingInstantiation (
            _environment_: unknown,
          )
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Assert: _environment_ is a declarative Environment Record.
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. If IsConstantDeclaration of |LetOrConst| is *true*, then
              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).
            1. Else,
              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).
        </emu-alg>
        <ins class="block">
        <emu-grammar>ForDeclaration : `using` ForBinding</emu-grammar>
        <emu-alg>
          1. Assert: _environment_ is a declarative Environment Record.
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: unknown,
            _stmt_: unknown,
            _iteratorRecord_: unknown,
            _iterationKind_: unknown,
            _lhsKind_: ~assignment~, ~varBinding~, or ~lexicalBinding~,
            _labelSet_: unknown,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _V_ be *undefined*.
          1. Let _destructuring_ be IsDestructuring of _lhs_.
          1. If _destructuring_ is *true* and if _lhsKind_ is ~assignment~, then
            1. Assert: _lhs_ is a |LeftHandSideExpression|.
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.
          1. Repeat,
            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).
            1. If Type(_nextResult_) is not Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_nextResult_).
            1. If _done_ is *true*, return _V_.
            1. Let _nextValue_ be ? IteratorValue(_nextResult_).
            1. If _lhsKind_ is either ~assignment~ or ~varBinding~, then
              1. If _destructuring_ is *false*, then
                1. Let _lhsRef_ be the result of evaluating _lhs_. (It may be evaluated repeatedly.)
              1. <ins>Let _iterationEnv_ be *undefined*.</ins>
            1. Else,
              1. Assert: _lhsKind_ is ~lexicalBinding~.
              1. Assert: _lhs_ is a |ForDeclaration|.
              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).
              1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.
              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.
              1. If _destructuring_ is *false*, then
                1. Assert: _lhs_ binds a single name.
                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.
                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).
            1. If _destructuring_ is *false*, then
              1. If _lhsRef_ is an abrupt completion, then
                1. Let _status_ be _lhsRef_.
              1. Else if _lhsKind_ is ~lexicalBinding~, then
                1. <del>Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).</del>
                1. <ins>If IsUsingDeclaration of _lhs_ is *true*, then</ins>
                  1. <ins>Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_, ~sync-dispose~)).</ins>
                1. <ins>Else,</ins>
                  1. <ins>Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_, ~normal~)).</ins>
              1. Else,
                1. Let _status_ be Completion(PutValue(_lhsRef_, _nextValue_)).
            1. Else,
              1. If _lhsKind_ is ~assignment~, then
                1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).
              1. Else if _lhsKind_ is ~varBinding~, then
                1. Assert: _lhs_ is a |ForBinding|.
                1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).
              1. Else,
                1. Assert: _lhsKind_ is ~lexicalBinding~.
                1. Assert: _lhs_ is a |ForDeclaration|.
                1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).
            1. If _status_ is an abrupt completion, then
              1. <ins>Set _status_ to DisposeResources(_iterationEnv_, _status_).</ins>
              1. Set the running execution context's LexicalEnvironment to _oldEnv_.
              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? _status_.
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. Let _result_ be the result of evaluating _stmt_.
            1. <ins>Set _result_ to DisposeResources(_iterationEnv_, _result_).</ins>
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. If LoopContinues(_result_, _labelSet_) is *false*, then
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? UpdateEmpty(_result_, _V_).
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).
                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>The `switch` Statement</h1>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be the result of evaluating |Expression|.
        1. Let _switchValue_ be ? GetValue(_exprRef_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).
        1. <ins>Let _env_ be _blockEnv_'s LexicalEnvironment.</ins>
        1. <ins>Set _R_ to DisposeResources(_env_, _R_).</ins>
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _R_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |SwitchStatement| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>

  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateFunctionBody (
          _functionObject_: unknown,
          _argumentsList_: a List,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. <del>Return the result of evaluating |FunctionStatementList|.</del>
        1. <ins>Let _result_ be result of evaluating |FunctionStatementList|.</ins>
        1. <ins>Let _env_ be the running execution context's LexicalEnvironment.</ins>
        1. <ins>Return ? DisposeResources(_env_, _result_).</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateOrdinaryFunctionExpression (
          optional _name_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
        1. Perform _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Perform _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |FunctionExpression| can be referenced from inside the |FunctionExpression|'s |FunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |FunctionExpression| cannot be referenced from and does not affect the scope enclosing the |FunctionExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>
    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateGeneratorFunctionExpression (
          optional _name_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        1. Perform DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
        1. Perform _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        1. Perform DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |GeneratorExpression| can be referenced from inside the |GeneratorExpression|'s |FunctionBody| to allow the generator code to call itself recursively. However, unlike in a |GeneratorDeclaration|, the |BindingIdentifier| in a |GeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |GeneratorExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression (
          optional _name_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateScope_).
        1. Perform ! SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncGeneratorExpression| can be referenced from inside the |AsyncGeneratorExpression|'s |AsyncGeneratorBody| to allow the generator code to call itself recursively. However, unlike in an |AsyncGeneratorDeclaration|, the |BindingIdentifier| in an |AsyncGeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncGeneratorExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateClassStaticBlockBody (
          _functionObject_: unknown,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, &laquo; &raquo;).
        1. <del>Return the result of evaluating |ClassStaticBlockStatementList|.</del>
        1. <ins>Let _result_ be result of evaluating |ClassStaticBlockStatementList|.</ins>
        1. <ins>Let _env_ be the running execution context's LexicalEnvironment.</ins>
        1. <ins>Return ? DisposeResources(_env_, _result_).</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: unknown,
          _className_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>
        <p>For example, an implementation could directly associate instance private methods with their corresponding Private Name and track, for each object, which class constructors have run with that object as their `this` value. Looking up an instance private method on an object then consists of checking that the class constructor which defines the method has been used to initialize the object, then returning the method associated with the Private Name.</p>
        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classScope_ be NewDeclarativeEnvironment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.CreateImmutableBinding(_classBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |ClassBody?| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody?|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name whose [[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] value is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage?| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classScope_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(_superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be ! OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody?| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If _constructor_ is ~empty~, then
          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
            1. If NewTarget is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be the active function object.
            1. If _F_.[[ConstructorKind]] is ~derived~, then
              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.
              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().
              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).
            1. Else,
              1. NOTE: This branch behaves similarly to `constructor() {}`.
              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
            1. Perform ? InitializeInstanceElements(_result_, _F_).
            1. Return _result_.
          1. Let _F_ be ! CreateBuiltinFunction(_defaultConstructor_, 0, _className_, &laquo; [[ConstructorKind]], [[SourceText]] &raquo;, the current Realm Record, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform ! MakeClassConstructor(_F_).
          1. Perform ! SetFunctionName(_F_, _className_).
        1. Perform ! MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage?| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform ! CreateMethodProperty(_proto_, *"constructor"*, _F_).
        1. If |ClassBody?| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _proto_.
          1. Else,
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _F_.
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return Completion(_element_).
          1. Set _element_ to _element_.[[Value]].
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement whose [[Key]] is _element_.[[Key]], then
              1. Let _existing_ be that PrivateElement.
              1. Assert: _element_.[[Kind]] and _existing_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _existing_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _existing_.[[Set]] }.
              1. Replace _existing_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.InitializeBinding(_classBinding_, _F_<ins>, ~normal~</ins>).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be DefineField(_F_, _elementRecord_).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be ? Call(_elementRecord_.[[BodyFunction]], _F_).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Return _F_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncFunctionExpression (
          optional _name_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_, _privateScope_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateScope_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateScope_).
        1. Perform ! SetFunctionName(_closure_, _name_).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncFunctionExpression| can be referenced from inside the |AsyncFunctionExpression|'s |AsyncFunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |AsyncFunctionExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncFunctionExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>Tail Position Calls</h1>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo">
      <h1>
        Static Semantics: HasCallInTailPosition (
          _call_: unknown,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_ is a Parse Node that represents a specific range of source text. When the following algorithms compare _call_ to another Parse Node, it is a test of whether they represent the same source text.</p>
      </emu-note>
      <ins class="block">
      <emu-note>
        <p>A `using` declaration that precedes a call in the same |Block|, |CaseBlock|, |ForStatement|, |ForInOfStatement|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, or |ClassStaticBlockBody| prevents that call from being a possible tail position call.</p>
      </emu-note>
      </ins>

      <emu-clause id="sec-statement-rules">
        <h1>Statement Rules</h1>
        <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. <ins>If HasUnterminatedUsingDeclaration of |StatementList| is *true*, return *false*.</ins>
          1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.
        </emu-alg>

        <emu-grammar>
          FunctionStatementList :
            [empty]

          StatementListItem :
            Declaration

          Statement :
            VariableStatement
            EmptyStatement
            ExpressionStatement
            ContinueStatement
            BreakStatement
            ThrowStatement
            DebuggerStatement

          Block :
            `{` `}`

          ReturnStatement :
            `return` `;`

          LabelledItem :
            FunctionDeclaration

          ForInOfStatement :
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

          CaseBlock :
            `{` `}`
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. Return HasCallInTailPosition of the second |Statement| with argument _call_.
        </emu-alg>
        <emu-grammar>
          IfStatement :
            `if` `(` Expression `)` Statement

          DoWhileStatement :
            `do` Statement `while` `(` Expression `)` `;`

          WhileStatement :
            `while` `(` Expression `)` Statement

          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement

          WithStatement :
            `with` `(` Expression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Statement| with argument _call_.
        </emu-alg>

        <emu-grammar>
          LabelledStatement :
            LabelIdentifier `:` LabelledItem
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.
        </emu-alg>

        <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Expression| with argument _call_.
        </emu-alg>

        <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.
        </emu-alg>

        <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
        <emu-alg>
          1. Let _has_ be *false*.
          1. If the first |CaseClauses| is present, <del>let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.</del><ins>then</ins>
            1. <ins>Let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.</del>
            1. <ins>If _has_ is *true*, return *true*.</ins>
            1. <ins>If HasUnterminatedUsingDeclaration of the first |CaseClauses| is *true*, return *false*.</ins>
          1. <del>If _has_ is *true*, return *true*.</del>
          1. Let _has_ be HasCallInTailPosition of |DefaultClause| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. <ins>If HasUnterminatedUsingDeclaration of |DefaultClause| is *true*, return *false*.</ins>
          1. If the second |CaseClauses| is present, let _has_ be HasCallInTailPosition of the second |CaseClauses| with argument _call_.
          1. Return _has_.
        </emu-alg>

        <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
        <emu-alg>
          1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.
          1. If _has_ is *true*, return *true*.
          1. <ins>If HasUnterminatedUsingDeclaration of |CaseClauses| is *true*, return *false*.</ins>
          1. Return HasCallInTailPosition of |CaseClause| with argument _call_.
        </emu-alg>

        <emu-grammar>
          CaseClause : `case` Expression `:` StatementList?

          DefaultClause : `default` `:` StatementList?
        </emu-grammar>
        <emu-alg>
          1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.
        </emu-alg>

        <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Catch| with argument _call_.
        </emu-alg>

        <emu-grammar>
          TryStatement :
            `try` Block Finally
            `try` Block Catch Finally
        </emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Finally| with argument _call_.
        </emu-alg>

        <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
        <emu-alg>
          1. Return HasCallInTailPosition of |Block| with argument _call_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-static-semantics-hasunterminatedusingdeclaration" type="sdo">
      <h1>Static Semantics: HasUnterminatedUsingDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasUnterminatedUsingDeclaration of |StatementList|.
        1. If _has_ is *true*, return *true*.
        1. Return HasUnterminatedUsingDeclaration of |StatementListItem|.
      </emu-alg>

      <emu-grammar>
        StatementListItem :
          Statement

        CaseBlock :
          `{` `}`

        Declaration :
          HoistableDeclaration
          ClassDeclaration

        LexicalDeclaration :
          LetOrConst BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>LexicalDeclaration : UsingDeclaration</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>

      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasUnterminatedUsingDeclaration of |CaseClauses|.
        1. If _has_ is *true*, return *true*.
        1. Return HasUnterminatedUsingDeclaration of |CaseClause| with argument _call_.
      </emu-alg>

      <emu-grammar>
        CaseClause :
          `case` Expression `:` StatementList?

        DefaultClause :
          `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. If |StatementList| is present, return HasUnterminatedUsingDeclaration of |StatementList|.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( )</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be ! HostResolveImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. NOTE: The above call cannot fail because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be ? GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Call _env_.InitializeBinding(_in_.[[LocalName]], _namespace_<ins>, ~normal~</ins>).
              1. Else,
                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be ? GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Call _env_.InitializeBinding(_in_.[[LocalName]], _namespace_<ins>, ~normal~</ins>).
                1. Else,
                  1. Call _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Call _env_.InitializeBinding(_dn_, *undefined*<ins>, ~normal~</ins>).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Call _env_.InitializeBinding(_dn_, _fo_<ins>, ~normal~</ins>).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return NormalCompletion(~empty~).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
          <h1>
            ExecuteModule (
              optional _capability_: unknown,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Suspend the currently running execution context.
            1. If _module_.[[HasTLA]] is *false*, then
              1. Assert: _capability_ is not present.
              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
              1. Let _result_ be the result of evaluating _module_.[[ECMAScriptCode]].
              1. <ins>Let _env_ be _moduleContext_'s LexicalEnvironment.</ins>
              1. <ins>Set _result_ to DisposeResources(_env_, _result_).</ins>
              1. Suspend _moduleContext_ and remove it from the execution context stack.
              1. Resume the context that is now on the top of the execution context stack as the running execution context.
              1. If _result_ is an abrupt completion, then
                1. Return ? _result_.
            1. Else,
              1. Assert: _capability_ is a PromiseCapability Record.
              1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-exports">
        <h1>Exports</h1>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          ExportDeclaration :
            `export` ExportFromClause FromClause `;`
            `export` NamedExports `;`
            `export` VariableStatement[~Yield, +Await]
            `export` <ins>[lookahead &notin; { `using` }]</ins> Declaration[~Yield, +Await]
            `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
            `export` `default` ClassDeclaration[~Yield, +Await, +Default]
            `export` `default` [lookahead &notin; {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, +Await] `;`

          ExportFromClause :
            `*`
            `*` `as` IdentifierName
            NamedExports

          NamedExports :
            `{` `}`
            `{` ExportsList `}`
            `{` ExportsList `,` `}`

          ExportsList :
            ExportSpecifier
            ExportsList `,` ExportSpecifier

          ExportSpecifier :
            IdentifierName
            IdentifierName `as` IdentifierName
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>The Global Object</h1>
  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>Function Properties of the Global Object</h1>
    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: unknown,
            _varEnv_: unknown,
            _lexEnv_: unknown,
            _privateEnv_: unknown,
            _strict_: unknown,
          )
        </h1>
        <dl class="header">
        </dl>
        <!--
          WARNING: If you add, remove, rename, or repurpose any variable names
                   within this algorithm, you may need to update
                   #sec-web-compat-evaldeclarationinstantiation and
                   #sec-variablestatements-in-catch-blocks accordingly.
        -->
        <emu-alg>
          1. Let _varNames_ be the VarDeclaredNames of _body_.
          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.
          1. If _strict_ is *false*, then
            1. If _varEnv_ is a global Environment Record, then
              1. For each element _name_ of _varNames_, do
                1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.
            1. Let _thisEnv_ be _lexEnv_.
            1. Assert: The following loop will terminate.
            1. Repeat, while _thisEnv_ is not the same as _varEnv_,
              1. If _thisEnv_ is not an object Environment Record, then
                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
                1. For each element _name_ of _varNames_, do
                  1. If _thisEnv_.HasBinding(_name_) is *true*, then
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding"] Throw a *SyntaxError* exception.
                    1. NOTE: Annex <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref> defines alternate semantics for the above step.
                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].
          1. Let _privateIdentifiers_ be a new empty List.
          1. Let _pointer_ be _privateEnv_.
          1. Repeat, while _pointer_ is not *null*,
            1. For each Private Name _binding_ of _pointer_.[[Names]], do
              1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.
            1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].
          1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.
          1. Let _functionsToInitialize_ be a new empty List.
          1. Let _declaredFunctionNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, in reverse List order, do
            1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Let _fn_ be the sole element of the BoundNames of _d_.
              1. If _fn_ is not an element of _declaredFunctionNames_, then
                1. If _varEnv_ is a global Environment Record, then
                  1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).
                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
                1. Append _fn_ to _declaredFunctionNames_.
                1. Insert _d_ as the first element of _functionsToInitialize_.
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-evaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
          1. Let _declaredVarNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, do
            1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. For each String _vn_ of the BoundNames of _d_, do
                1. If _vn_ is not an element of _declaredFunctionNames_, then
                  1. If _varEnv_ is a global Environment Record, then
                    1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).
                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                  1. If _vn_ is not an element of _declaredVarNames_, then
                    1. Append _vn_ to _declaredVarNames_.
          1. [id="step-evaldeclarationinstantiation-post-validation"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a global Environment Record and the global object is a Proxy exotic object.
          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.
          1. For each element _d_ of _lexDeclarations_, do
            1. NOTE: Lexically declared names are only instantiated here but not initialized.
            1. For each element _dn_ of the BoundNames of _d_, do
              1. If IsConstantDeclaration of _d_ is *true*, then
                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).
              1. Else,
                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).
          1. For each Parse Node _f_ of _functionsToInitialize_, do
            1. Let _fn_ be the sole element of the BoundNames of _f_.
            1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
            1. If _varEnv_ is a global Environment Record, then
              1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnv_.HasBinding(_fn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnv_.CreateMutableBinding(_fn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_<ins>, ~normal~</ins>).
              1. Else,
                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
          1. For each String _vn_ of _declaredVarNames_, do
            1. If _varEnv_ is a global Environment Record, then
              1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnv_.HasBinding(_vn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnv_.CreateMutableBinding(_vn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*<ins>, ~normal~</ins>).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <emu-note>
          <p>An alternative version of this algorithm is described in <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-%iteratorprototype%-object">
      <h1>The %IteratorPrototype% Object</h1>

      <ins class="block">
      <emu-clause id="sec-%iteratorprototype%-@@dispose">
        <h1>%IteratorPrototype% [ @@dispose ] ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _return_ be ? GetMethod(_O_, `"return"`).
          1. If _return_ is not *undefined*, then
            1. Perform ? Call(_return_, _O_, &laquo; &raquo;).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.dispose]"*.</p>
      </emu-clause>
      </ins>
    </emu-clause>

    <emu-clause id="sec-%asynciteratorprototype%-object">
      <h1>The %AsyncIteratorPrototype% Object</h1>

      <ins class="block">
      <emu-clause id="sec-%asynciteratorprototype%-@@asyncdispose">
        <h1>%AsyncIteratorPrototype% [ @@asyncDispose ] ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _return_ be GetMethod(_O_, `"return"`).
          1. IfAbruptRejectPromise(_return_, _promiseCapability_).
          1. If _return_ is *undefined*, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
          1. Else,
            1. Let _result_ be Call(_return_, _O_, &laquo; *undefined* &raquo;).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.asyncDispose]"*.</p>
      </emu-clause>
      </ins>
    </emu-clause>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-resource-management">
    <h1>Resource Management</h1>

    <emu-clause id="sec-common-resource-management-interfaces">
      <h1>Common Resource Management Interfaces</h1>
      <p>An interface is a set of property keys whose associated values match a specific specification. Any object that provides all the properties as described by an interface's specification <em>conforms</em> to that interface. An interface is not represented by a distinct object. There may be many separately implemented objects that conform to any interface. An individual object may conform to multiple interfaces.</p>

      <emu-clause id="sec-disposable-interface">
        <h1>The <em>Disposable</em> Interface</h1>
        <p>The <em>Disposable</em> interface includes the property described in <emu-xref href="#table-disposable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-disposable-interface-required-properties" caption="&lt;em&gt;Disposable&lt;/em&gt; Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `@@dispose`
              </td>
              <td>
                A function.
              </td>
              <td>
                <p>Invoking this method notifies the <em>Disposable</em> object that the caller does not intend to continue to use this object. This method should perform any necessary logic to perform explicit clean-up of the resource including, but not limited to, file system handles, streams, host objects, etc. When an exception is thrown from this method, it typically means that the resource could not be explicitly freed.</p>
                <p>If called more than once on the same object, the function should not throw an exception. However, this requirement is not enforced.</p>
                <p>When using a <em>Disposable</em> object, it is good practice to create the instance with a `using` declaration, as the resource will be automatically disposed when the |Block| or |Module| immediately containing the declaration has been evaluated.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncdisposable-interface">
        <h1>The <em>AsyncDisposable</em> Interface</h1>
        <p>The <em>AsyncDisposable</em> interface includes the property described in <emu-xref href="#table-asyncdisposable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-asyncdisposable-interface-required-properties" caption="&lt;em&gt;AsyncDisposable&lt;/em&gt; Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `@@asyncDispose`
              </td>
              <td>
                A function that returns a promise.
              </td>
              <td>
                <p>Invoking this method notifies the <em>AsyncDisposable</em> object that the caller does not intend to continue to use this object. This method should perform any necessary logic to perform explicit clean-up of the resource including, but not limited to, file system handles, streams, host objects, etc. When an exception is thrown from this method, it typically means that the resource could not be explicitly freed. An <em>AsyncDisposable</em> object is not considered "disposed" until the resulting Promise has been fulfilled.</p>
                <p>If called more than once on the same object, the function should not throw an exception. However, this requirement is not enforced.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  </ins>

  <ins class="block">
  <emu-clause id="sec-disposablestack-objects">
    <h1>DisposableStack Objects</h1>
    <p>A DisposableStack is an object that can be used to contain one or more resources that should be disposed together.</p>
    <p>Any DisposableStack object is in one of two mutually exclusive states: <em>disposed</em> or <em>pending</em>:</p>
    <ul>
      <li>A disposable stack `d` is pending if `d[Symbol.dispose]()` has yet to be invoked for `d`.</li>
      <li>A disposable stack `d` is disposed if `d[Symbol.dispose]()` has already been invoked once for `d`.</li>
    </ul>

    <emu-clause id="sec-disposablestack-constructor">
      <h1>The DisposableStack Constructor</h1>
      <p>The DisposableStack constructor:</p>
      <ul>
        <li>is <dfn>%DisposableStack%</dfn>.</li>
        <li>is the initial value of the *"DisposableStack"* property of the global object.</li>
        <li>creates and initializes a new DisposableStack when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified DisposableStack behaviour must include a `super` call to the DisposableStack constructor to create and initialize the subclass instance with the internal state necessary to support the `DisposableStack` and `DisposableStack.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-disposablestack">
        <h1>DisposableStack ( )</h1>
        <p>When the `DisposableStack` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _disposableStack_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DisposableStack.prototype%"*, &laquo; [[DisposableState]], [[DisposableResourceStack]], [[BoundDispose]] &raquo;).
          1. Set _disposableStack_.[[DisposableState]] to ~pending~.
          1. Set _disposableStack_.[[DisposableResourceStack]] to a new empty List.
          1. Set _disposableStack_.[[BoundDispose]] to *undefined*.
          1. Return _disposableStack_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-disposablestack-constructor">
      <h1>Properties of the DisposableStack Constructor</h1>
      <p>The DisposableStack constructor:</p>
      <ul>
        <li>Has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <!--
      NOTE: If we decide not to support @@species, the following clause should be removed:
      -->
      <emu-clause id="sec-get-disposablestack-@@species">
        <h1>get DisposableStack [ @@species ]</h1>
        <p>`DisposableStack[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-disposablestack-prototype-object">
      <h1>Properties of the DisposableStack Prototype Object</h1>
      <p>The <dfn>DisposableStack prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%DisposableStack.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[DisposableState]] internal slot or any of the other internal slots of DisposableStack instances.</li>
      </ul>

      <emu-clause id="sec-get-disposablestack.prototype.dispose">
        <h1>get DisposableStack.prototype.dispose</h1>
        <p>`DisposableStack.prototype.dispose` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[BoundDispose]] is *undefined*, then
            1. Let _dispose_ be GetMethod(_disposableStack_, @@dispose).
            1. If _dispose_ is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-disposablestack-dispose-functions"></emu-xref>.
            1. Set _F_.[[DisposableStack]] to _disposableStack_.
            1. Set _F_.[[DisposeMethod]] to _dispose_.
            1. Set _disposableStack_.[[BoundDispose]] to _F_.
          1. Return _disposableStack_.[[BoundDispose]].
        </emu-alg>

        <emu-clause id="sec-disposablestack-dispose-functions">
          <h1>DisposableStack Dispose Functions</h1>
          <p>A <dfn>DisposableStack dispose function</dfn> is an anonymous built-in function object that has [[DisposableStack]] and [[DisposeMethod]] internal slots.</p>
          <p>When a DisposableStack dispose function is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _disposableStack_ be _F_.[[DisposableStack]].
            1. Let _dispose_ be _F_.[[DisposeMethod]].
            1. Assert: Type(_disposableStack_) is Object and _disposableStack_ has a [[DisposableState]] internal slot.
            1. Assert: IsCallable(_dispose_) is *true*.
            1. Return Call(_dispose_, _disposableStack_, &laquo; &raquo;).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.use">
        <h1>DisposableStack.prototype.use( _value_ [, _onDispose_ ] )</h1>
        <p>When the `use` function is called with one or two arguments, the following steps are taken:</p>
        <emu-note>
          <p>The _onDispose_ argument is optional. If it is not provided, *undefined* is used.</p>
        </emu-note>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If _onDispose_ is not *undefined*, then
            1. If IsCallable(_onDispose_) is *false*, throw a *TypeError* exception.
            1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-disposablestack-callback-functions"></emu-xref>.
            1. Set _F_.[[Argument]] to _value_.
            1. Set _F_.[[OnDisposeCallback]] to _onDispose_.
            1. Perform ? AddDisposableResource(_disposableStack_, *undefined*, ~sync-dispose~, _F_).
          1. Else, if _value_ is neither *null* nor *undefined*, then
            1. If Type(_value_) is not Object, throw a *TypeError* exception.
            1. Let _method_ be GetDisposeMethod(_value_, ~sync-dispose~).
            1. If _method_ is *undefined*, then
              1. If IsCallable(_value_) is *true*, then
                1. Perform ? AddDisposableResource(_disposableStack_, *undefined*, ~sync-dispose~, _value_).
              1. Else,
                1. Throw a *TypeError* exception.
            1. Else,
              1. Perform ? AddDisposableResource(_disposableStack_, _value_, ~sync-dispose~, _method_).
          1. Return _value_.
        </emu-alg>

        <emu-clause id="sec-disposablestack-callback-functions">
          <h1>DisposableStack Callback Functions</h1>
          <p>A <dfn>DisposableStack callback function</dfn> is an anonymous built-in function object that has [[Argument]] and [[OnDisposeCallback]] internal slots.</p>
          <p>When a DisposableStack callback function is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: IsCallable(_F_.[[OnDisposeCallback]]) is *true*.
            1. Return Call(_F_.[[OnDisposeCallback]], *undefined*, &laquo; _F_.[[Argument]] &raquo;).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.move">
        <h1>DisposableStack.prototype.move()</h1>
        <p>When the `move` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          <!--
          NOTE: If we decide not to support @@species, the following steps should be removed:
          -->
          1. Let _C_ be ? SpeciesConstructor(_disposableStack_, %DisposableStack%).
          1. Assert: IsConstructor(_C_) is *true*.
          1. Let _newDisposableStack_ be ? Construct(_C_, &laquo; &raquo;).
          1. Perform ? RequireInternalSlot(_newDisposableStack_, [[DisposableState]]).
          1. If _newDisposableStack_.[[DisposableState]] is not ~pending~, throw a *TypeError* exception.
          1. Append each element of _disposableStack_.[[DisposableResourceStack]] to _newDisposableStack_.[[DisposableResourceStack]].
          <!--
          NOTE: If we decide not to support @@species, we can use these steps instead:

          1. Let _newDisposableStack_ be ? OrdinaryCreateFromConstructor(%DisposableStack%, *"%DisposableStack.prototype%"*, &laquo; [[DisposableState]], [[DisposableResourceStack]], [[BoundDispose]] &raquo;).
          1. Set _newDisposableStack_.[[DisposableState]] to ~pending~.
          1. Set _newDisposableStack_.[[DisposableResourceStack]] to _disposableStack_.[[DisposableResourceStack]].
          1. Set _newDisposableStack_.[[BoundDispose]] to *undefined*.
          -->
          1. Set _disposableStack_.[[DisposableResourceStack]] to a new empty List.
          1. Return _newDisposableStack_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype-@@dispose">
        <h1>DisposableStack.prototype [ @@dispose ] ()</h1>
        <p>When the `@@dispose` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, return *undefined*.
          1. Set _disposableStack_.[[DisposableState]] to ~disposed~.
          1. Return DisposeResources(_disposableStack_, NormalCompletion(*undefined*)).
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.dispose]"*.</p>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype-@@toStringTag">
        <h1>DisposableStack.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the `@@toStringTag` property is the String value *"DisposableStack"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-disposablestack-instances">
      <h1>Properties of DisposableStack Instances</h1>
      <p>DisposableStack instances are ordinary objects that inherit properties from the DisposableStack prototype object (the intrinsic %DisposableStack.prototype%). DisposableStack instances are initially created with internal slots described in <emu-xref href="#table-internal-slots-of-disposablestack-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-disposablestack-instances" caption="Internal Slots of DisposableStack Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[DisposableState]]
            </td>
            <td>
              One of ~pending~ or ~disposed~. Governs how a disposable stack will react to incoming calls to its `@@dispose` method.
            </td>
          </tr>
          <tr>
            <td>
              [[DisposableResourceStack]]
            </td>
            <td>
              A List of DisposableResource Records.
            </td>
          </tr>
          <tr>
            <td>
              [[BoundDispose]]
            </td>
            <td>
              Either *undefined* or a function object that caches the function returned by the `DisposableStack.prototype.dispose` accessor (<emu-xref href="#sec-get-disposablestack.prototype.dispose"></emu-xref>).
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
  </ins>

  <ins class="block">
  <emu-clause id="sec-asyncdisposablestack-objects">
    <h1>AsyncDisposableStack Objects</h1>
    <p>An AsyncDisposableStack is an object that can be used to contain one or more resources that should be asynchronously disposed together.</p>
    <p>Any AsyncDisposableStack object is in one of two mutually exclusive states: <em>disposed</em> or <em>pending</em>:</p>
    <ul>
      <li>An async-disposable stack `d` is pending if `d[Symbol.asyncDispose]()` has yet to be invoked for `d`.</li>
      <li>An async-disposable stack `d` is disposed if `d[Symbol.asyncDispose]()` has already been invoked once for `d`.</li>
    </ul>

    <emu-clause id="sec-asyncdisposablestack-constructor">
      <h1>The AsyncDisposableStack Constructor</h1>
      <p>The AsyncDisposableStack constructor:</p>
      <ul>
        <li>is <dfn>%AsyncDisposableStack%</dfn>.</li>
        <li>is the initial value of the *"AsyncDisposableStack"* property of the global object.</li>
        <li>creates and initializes a new AsyncDisposableStack when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncDisposableStack behaviour must include a `super` call to the AsyncDisposableStack constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncDisposableStack` and `AsyncDisposableStack.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asyncdisposablestack">
        <h1>AsyncDisposableStack ( )</h1>
        <p>When the `AsyncDisposableStack` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _asyncDisposableStack_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncDisposableStack.prototype%"*, &laquo; [[AsyncDisposableState]], [[DisposableResourceStack]], [[BoundDisposeAsync]] &raquo;).
          1. Set _asyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
          1. Set _asyncDisposableStack_.[[DisposableResourceStack]] to a new empty List.
          1. Set _asyncDisposableStack_.[[BoundDisposeAsync]] to *undefined*.
          1. Return _asyncDisposableStack_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asyncdisposablestack-constructor">
      <h1>Properties of the AsyncDisposableStack Constructor</h1>
      <p>The AsyncDisposableStack constructor:</p>
      <ul>
        <li>Has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <!--
      NOTE: If we decide not to support @@species, the following clause should be removed:
      -->
      <emu-clause id="sec-get-asyncdisposablestack-@@species">
        <h1>get AsyncDisposableStack [ @@species ]</h1>
        <p>`AsyncDisposableStack[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asyncdisposablestack-prototype-object">
      <h1>Properties of the AsyncDisposableStack Prototype Object</h1>
      <p>The <dfn>AsyncDisposableStack prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncDisposableStack.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[AsyncDisposableState]] internal slot or any of the other internal slots of AsyncDisposableStack instances.</li>
      </ul>

      <emu-clause id="sec-get-asyncdisposablestack.prototype.disposeAsync">
        <h1>get AsyncDisposableStack.prototype.disposeAsync</h1>
        <p>`AsyncDisposableStack.prototype.disposeAsync` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[BoundDisposeAsync]] is *undefined*, then
            1. Let _disposeAsync_ be GetMethod(_asyncDisposableStack_, @@asyncDispose).
            1. If _disposeAsync_ is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-asyncdisposablestack-dispose-functions"></emu-xref>.
            1. Set _F_.[[AsyncDisposableStack]] to _asyncDisposableStack_.
            1. Set _F_.[[DisposeAsyncMethod]] to _disposeAsync_.
            1. Set _asyncDisposableStack_.[[BoundDisposeAsync]] to _F_.
          1. Return _asyncDisposableStack_.[[BoundDisposeAsync]].
        </emu-alg>

        <emu-clause id="sec-asyncdisposablestack-dispose-functions">
          <h1>AsyncDisposableStack Dispose Functions</h1>
          <p>An AsyncDisposableStack dispose function is an anonymous built-in function that has [[AsyncDisposableStack]] and [[DisposeAsyncMethod]] internal slots.</p>
          <p>When an AsyncDisposableStack dispose function is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _asyncDisposableStack_ be _F_.[[AsyncDisposableStack]].
            1. Let _disposeAsync_ be _F_.[[DisposeAsyncMethod]].
            1. Assert: Type(_asyncDisposableStack_) is Object and _asyncDisposableStack_ has an [[AsyncDisposableState]] internal slot.
            1. Assert: IsCallable(_disposeAsync_) is *true*.
            1. Return Call(_disposeAsync_, _asyncDisposableStack_, &laquo; &raquo;).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.use">
        <h1>AsyncDisposableStack.prototype.use( _value_ [, _onDisposeAsync_ ] )</h1>
        <p>When the `use` function is called with one or two arguments, the following steps are taken:</p>
        <emu-note>
          <p>The _onDisposeAsync_ argument is optional. If it is not provided, *undefined* is used.</p>
        </emu-note>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If _onDisposeAsync_ is not *undefined*, then
            1. If IsCallable(_onDisposeAsync_) is *false*, throw a *TypeError* exception.
            1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-asyncdisposablestack-callback-functions"></emu-xref>.
            1. Set _F_.[[Argument]] to _value_.
            1. Set _F_.[[OnDisposeAsyncCallback]] to _onDisposeAsync_.
            1. Perform ? AddDisposableResource(_asyncDisposableStack_, *undefined*, ~async-dispose~, _F_).
          1. Else, if _value_ is neither *null* nor *undefined*, then
            1. If Type(_value_) is not Object, throw a *TypeError* exception.
            1. Let _method_ be GetDisposeMethod(_value_, ~async-dispose~).
            1. If _method_ is *undefined*, then
              1. If IsCallable(_value_) is *true*, then
                1. Perform ? AddDisposableResource(_disposableStack_, *undefined*, ~async-dispose~, _value_).
              1. Else,
                1. Throw a *TypeError* exception.
            1. Else,
              1. Perform ? AddDisposableResource(_disposableStack_, _value_, ~async-dispose~, _method_).
          1. Return _value_.
        </emu-alg>

        <emu-clause id="sec-asyncdisposablestack-callback-functions">
          <h1>AsyncDisposableStack Callback Functions</h1>
          <p>An AsyncDisposableStack callback function is an anonymous built-in function that has [[Argument]] and [[OnDisposeAsyncCallback]] internal slots.</p>
          <p>When an AsyncDisposableStack callback function is called, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: IsCallable(_F_.[[OnDisposeAsyncCallback]]) is *true*.
            1. Return Call(_F_.[[OnDisposeAsyncCallback]], *undefined*, &laquo; _F_.[[Argument]] &raquo;).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.move">
        <h1>AsyncDisposableStack.prototype.move()</h1>
        <p>When the `move` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          <!--
          NOTE: If we decide not to support @@species, the following steps should be removed:
          -->
          1. Let _C_ be ? SpeciesConstructor(_asyncDisposableStack_, %AsyncDisposableStack%).
          1. Assert: IsConstructor(_C_) is *true*.
          1. Let _newAsyncDisposableStack_ be ? Construct(_C_, &laquo; &raquo;).
          1. Perform ? RequireInternalSlot(_newAsyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _newAsyncDisposableStack_.[[AsyncDisposableState]] is not ~pending~, throw a *TypeError* exception.
          1. Append each element of _asyncDisposableStack_.[[DisposableResourceStack]] to _newAsyncDisposableStack_.[[DisposableResourceStack]].
          <!--
          NOTE: If we decide not to support @@species, we can use these steps instead:

          1. Let _newAsyncDisposableStack_ be ? OrdinaryCreateFromConstructor(%AsyncDisposableStack, *"%AsyncDisposableStack.prototype%"*, &laquo; [[AsyncDisposableState]], [[DisposableResourceStack]], [[BoundDisposeAsync]] &raquo;).
          1. Set _newAsyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
          1. Set _newAsyncDisposableStack_.[[DisposableResourceStack]] to _asyncDisposableStack_.[[DisposableResourceStack]].
          1. Set _newAsyncDisposableStack_.[[BoundDisposeAsync]] to *undefined*.
          -->
          1. Set _asyncDisposableStack_.[[DisposableResourceStack]] to a new empty List.
          1. Return _newAsyncDisposableStack_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype-@@asyncDispose">
        <h1>AsyncDisposableStack.prototype [ @@asyncDispose ] ()</h1>
        <p>When the `@@asyncDispose` method is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. If _asyncDisposableStack_ does not have a [[DisposableState]] internal slot, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
            1. Return _promiseCapability_.[[Promise]].
          1. If _asyncDisposableStack_.[[DisposableState]] is ~disposed~, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            1. Return _promiseCapability_.[[Promise]].
          1. Set _asyncDisposableStack_.[[DisposableState]] to ~disposed~.
          1. Let _result_ be DisposeResources(_asyncDisposableStack_, NormalCompletion(*undefined*)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_ &raquo;).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.asyncDispose]"*.</p>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype-@@toStringTag">
        <h1>AsyncDisposableStack.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the `@@toStringTag` property is the String value *"AsyncDisposableStack"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncdisposablestack-instances">
      <h1>Properties of AsyncDisposableStack Instances</h1>
      <p>AsyncDisposableStack instances are ordinary objects that inherit properties from the AsyncDisposableStack prototype object (the intrinsic %AsyncDisposableStack.prototype%). AsyncDisposableStack instances are initially created with internal slots described in <emu-xref href="#table-internal-slots-of-asyncdisposablestack-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-asyncdisposablestack-instances" caption="Internal Slots of AsyncDisposableStack Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncDisposableState]]
            </td>
            <td>
              One of ~pending~ or ~disposed~. Governs how a disposable stack will react to incoming calls to its `@@asyncDispose` method.
            </td>
          </tr>
          <tr>
            <td>
              [[DisposableResourceStack]]
            </td>
            <td>
              A List of DisposableResource records.
            </td>
          </tr>
          <tr>
            <td>
              [[BoundDisposeAsync]]
            </td>
            <td>
              Either *undefined* or a function object that caches the function returned by the `AsyncDisposableStack.prototype.disposeAsync` accessor (<emu-xref href="#sec-get-asyncdisposablestack.prototype.disposeAsync"></emu-xref>).
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
  </ins>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: unknown,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. [fence-effects="user-code"] Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be the result of evaluating _generatorBody_.
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be _generatorBody_().
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _generator_.[[GeneratorState]] to ~completed~.
            1. Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. <ins>Let _env_ be _genContext_'s LexicalEnvironment.</ins>
            1. <ins>Set _result_ to DisposeResources(_env_, _result_).</ins>
            1. If _result_.[[Type]] is ~normal~, let _resultValue_ be *undefined*.
            1. Else if _result_.[[Type]] is ~return~, let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Return ? _result_.
            1. Return CreateIterResultObject(_resultValue_, *true*).
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. Set _generator_.[[GeneratorState]] to ~suspendedStart~.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. [fence-effects="user-code"] Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be the result of evaluating _generatorBody_.
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.
            1. <ins>Let _env_ be _genContext_'s LexicalEnvironment.</ins>
            1. <ins>Set _result_ to DisposeResources(_env_, _result_).</ins>
            1. If _result_.[[Type]] is ~normal~, set _result_ to NormalCompletion(*undefined*).
            1. If _result_.[[Type]] is ~return~, set _result_ to NormalCompletion(_result_.[[Value]]).
            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return *undefined*.
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~suspendedStart~.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction Objects</h1>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async Functions Abstract Operations</h1>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promiseCapability_ is a PromiseCapability Record.
          1. Let _runningContext_ be the running execution context.
          1. [fence-effects="user-code"] Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
            1. Let _result_ be the result of evaluating _asyncBody_.
            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
            1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. <ins>Let _env_ be _asyncContext_'s LexicalEnvironment.</ins>
            1. <ins>Set _result_ to DisposeResources(_env_, _result_).</ins>
            1. If _result_.[[Type]] is ~normal~, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            1. Else if _result_.[[Type]] is ~return~, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            1. [id="step-asyncblockstart-return-undefined"] Return ~unused~.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref> above.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>Additional ECMAScript Features for Web Browsers</h1>
  <emu-annex id="sec-other-additional-features">
    <h1>Other Additional Features</h1>
    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>Block-Level Function Declarations Web Legacy Compatibility Semantics</h1>
      <emu-annex id="sec-web-compat-blockdeclarationinstantiation">
        <h1>Changes to BlockDeclarationInstantiation</h1>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref>:</p>
        <emu-alg replaces-step="step-blockdeclarationinstantiation-createmutablebinding">
          1. If _env_.HasBinding(_dn_) is *false*, then
            1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
        </emu-alg>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref>:</p>
        <emu-alg replaces-step="step-blockdeclarationinstantiation-initializebinding">
          1. If the binding for _fn_ in _env_ is an uninitialized binding, then
            1. Perform _env_.InitializeBinding(_fn_, _fo_<ins>, ~normal~</ins>).
          1. Else,
            1. Assert: _d_ is a |FunctionDeclaration|.
            1. Perform _env_.SetMutableBinding(_fn_, _fo_, *false*).
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>
</emu-annex>
