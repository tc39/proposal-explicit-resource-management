<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<link rel="spec" href="es2015" />
<style>
  h1.ins {
    background-color: #e0f8e0;
    text-decoration: none;
    border-bottom: 1px solid #396;
  }
  hr {
    height: 0.25em;
    background: #ccc;
    border: 0;
    margin: 2em 0;
  }
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }
  .unicode-property-table ul {
    padding-left: 0;
    list-style: none;
  }

</style>
<pre class="metadata">
title: ECMAScript Explicit Resource Management
status: proposal
stage: 3
contributors: Ron Buckton, Ecma International
</pre>

<emu-biblio href="node_modules/@tc39/ecma262-biblio/biblio.json"></emu-biblio>

<emu-intro id="intro">
  <h1>Introduction</h1>
  <p>This proposal introduces syntax and semantics around explicit resource management.</p>
  <p>See <a href="https://github.com/tc39/proposal-explicit-resource-management">the proposal repository</a> for background material and discussion.</p>
</emu-intro>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>
    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>The Symbol Type</h1>
      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>@@asyncDispose</ins>
              </td>
              <td>
                <ins>`"Symbol.asyncDispose"`</ins>
              </td>
              <td>
                <ins>A method that performs explicit resource cleanup on an object. Called by the semantics of the `await using` declaration and AsyncDisposableStack objects.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>@@dispose</ins>
              </td>
              <td>
                <ins>`"Symbol.dispose"`</ins>
              </td>
              <td>
                <ins>A method that performs explicit resource cleanup on an object. Called by the semantics of the `using` declaration and DisposableStack objects.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>Well-Known Intrinsic Objects</h1>
        <emu-table id="table-well-known-intrinsic-objects" caption="Well-Known Intrinsic Objects" oldids="table-7">
          <table>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                The `AggregateError` constructor (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                The Array constructor (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                The ArrayBuffer constructor (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Array iterator objects (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%AsyncDisposableStack%</ins>
              </td>
              <td>
                <ins>`AsyncDisposableStack`</ins>
              </td>
              <td>
                <ins>The AsyncDisposableStack constructor (<emu-xref href="#sec-asyncdisposablestack-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async-from-sync iterator objects (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async function objects (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async iterator objects (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                The `Atomics` object (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                The BigInt constructor (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                The BigInt64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                The BigUint64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                The Boolean constructor (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                The DataView constructor (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                The Date constructor (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                The `decodeURI` function (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                The `decodeURIComponent` function (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%DisposableStack%</ins>
              </td>
              <td>
                <ins>`DisposableStack`</ins>
              </td>
              <td>
                <ins>The DisposableStack constructor (<emu-xref href="#sec-disposablestack-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                The `encodeURI` function (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                The `encodeURIComponent` function (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                The Error constructor (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                The `eval` function (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                The EvalError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                The FinalizationRegistry constructor (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                The Float32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                The Float64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of For-In iterator objects (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                The Function constructor (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of Generators (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                The Int8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                The Int16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                The Int32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                The `isFinite` function (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                The `isNaN` function (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                The `JSON` object (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                The Map constructor (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Map iterator objects (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                The `Math` object (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                The Number constructor (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                The Object constructor (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                The `parseFloat` function (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                The `parseInt` function (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                The Promise constructor (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                The Proxy constructor (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                The RangeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                The ReferenceError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                The `Reflect` object (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                The RegExp constructor (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of RegExp String Iterator objects (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                The Set constructor (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Set iterator objects (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                The SharedArrayBuffer constructor (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                The String constructor (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of String iterator objects (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%SuppressedError%</ins>
              </td>
              <td>
                <ins>`SuppressedError`</ins>
              </td>
              <td>
                <ins>The `SuppressedError` constructor (<emu-xref href="#sec-suppressederror-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                The Symbol constructor (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                The SyntaxError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                A function object that unconditionally throws a new instance of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                The super class of all typed Array constructors (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                The TypeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                The Uint8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                The Uint8ClampedArray constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                The Uint16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                The Uint32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                The URIError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                The WeakMap constructor (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                The WeakRef constructor (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                The WeakSet constructor (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>The Reference Record Specification Type</h1>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: a Reference Record,
            _W_: a Reference Record,
            <ins>_hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~,</ins>
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsUnresolvableReference(_V_) is *false*.
          1. Let _base_ be _V_.[[Base]].
          1. Assert: _base_ is an Environment Record.
          1. Return ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_<ins>, _hint_</ins>).
        </emu-alg>
      </emu-clause>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>

  <ins class="block">
  <emu-clause id="sec-operations-on-disposable-objects">
    <h1>Operations on Disposable Objects</h1>
    <p>See Common Resource Management Interfaces (<emu-xref href="#sec-common-resource-management-interfaces"></emu-xref>).</p>
    <emu-clause id="sec-disposecapability-records">
      <h1>DisposeCapability Records</h1>
      <p>A <dfn variants="DisposeCapability Records">DisposeCapability Record</dfn> is a Record value used to contain a List of DisposableResource Records that are disposed together. DisposeCapability Records are produced by the NewDisposeCapability abstract operation.</p>
      <p>DisposeCapability Records have the fields listed in <emu-xref href="#table-disposecapability-record-fields"></emu-xref>:</p>
      <emu-table id="table-disposecapability-record-fields" caption="DisposeCapability Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[DisposableResourceStack]]
            </td>
            <td>
              A List of DisposableResource Records.
            </td>
            <td>
              The resources to be disposed. Resources are added in the order they are initialized, and are disposed in reverse order.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-disposableresource-records">
      <h1>DisposableResource Records</h1>
      <p>A <dfn variants="DisposableResource Records">DisposableResource Record</dfn> is a Record value used to encapsulate a disposable object along with the method used to dispose the object. DisposableResource Records are produced by the CreateDisposableResource abstract operation.</p>
      <p>DisposableResource Records have the fields listed in <emu-xref href="#table-disposableresource-record-fields"></emu-xref>:</p>
      <emu-table id="table-disposableresource-record-fields" caption="DisposableResource Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[ResourceValue]]
            </td>
            <td>
              An Object or *undefined*.
            </td>
            <td>
              The value to be disposed.
            </td>
          </tr>
          <tr>
            <td>
              [[Hint]]
            </td>
            <td>
              ~sync-dispose~ or ~async-dispose~.
            </td>
            <td>
              Indicates whether the resource was added by a `using` declaration or DisposableStack object (~sync-dispose~) or by an `await using` declaration or AsyncDisposableStack object (~async-dispose~).
            </td>
          </tr>
          <tr>
            <td>
              [[DisposeMethod]]
            </td>
            <td>
              A function object or *undefined*.
            </td>
            <td>
              A function object that will be called with [[ResourceValue]] as its *this* value when the resource disposed.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-newdisposecapability" type="abstract operation">
      <h1>
        NewDisposeCapability (
        ): a DisposeCapability Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _stack_ be a new empty List.
        1. Return the DisposeCapability Record { [[DisposableResourceStack]]: _stack_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-adddisposableresource" type="abstract operation">
      <h1>
        AddDisposableResource (
          _disposeCapability_ : a DisposeCapability Record,
          _V_ : an ECMAScript language value,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          optional _method_ : a function object,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _method_ is not present then,
          1. If _V_ is either *null* or *undefined* and _hint_ is ~sync-dispose~, then
            1. Return ~unused~.
          1. NOTE: When _V_ is either *null* or *undefined* and _hint_ is ~async-dispose~, we record that the resource was evaluated to ensure we will still perform an Await when resources are later disposed.
          1. Let _resource_ be ? CreateDisposableResource(_V_, _hint_).
        1. Else,
          1. Assert: _V_ is *undefined*.
          1. Let _resource_ be ? CreateDisposableResource(*undefined*, _hint_, _method_).
        1. Append _resource_ to _disposeCapability_.[[DisposableResourceStack]].
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdisposableresource" type="abstract operation">
      <h1>
        CreateDisposableResource (
          _V_ : an ECMAScript language value,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          optional _method_ : a function object,
        ): either a normal completion containing a DisposableResource Record or a throw completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _method_ is not present, then
          1. If _V_ is either *null* or *undefined*, then
            1. Set _V_ to *undefined*.
            1. Set _method_ to *undefined*.
          1. Else,
            1. If _V_ is not an Object, throw a *TypeError* exception.
            1. Set _method_ to ? GetDisposeMethod(_V_, _hint_).
            1. If _method_ is *undefined*, throw a *TypeError* exception.
        1. Else,
          1. If IsCallable(_method_) is *false*, throw a *TypeError* exception.
        1. Return the DisposableResource Record { [[ResourceValue]]: _V_, [[Hint]]: _hint_, [[DisposeMethod]]: _method_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getdisposemethod" type="abstract operation">
      <h1>
        GetDisposeMethod (
          _V_ : an Object,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
        ): either a normal completion containing either a function object or *undefined*, or a throw completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _hint_ is ~async-dispose~, then
          1. Let _method_ be ? GetMethod(_V_, @@asyncDispose).
          1. If _method_ is *undefined*, then
            1. Set _method_ to ? GetMethod(_V_, @@dispose).
            1. If _method_ is not *undefined*, then
              1. Let _closure_ be a new Abstract Closure with no parameters that captures _method_ and performs the following steps when called:
                1. Let _O_ be the *this* value.
                1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
                1. Let _result_ be Completion(Call(_method_, _O_)).
                1. IfAbruptRejectPromise(_result_, _promiseCapability_).
                1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
                1. Return _promiseCapability_.[[Promise]].
              1. NOTE: This function is not observable to user code. It is used to ensure that a Promise returned from a synchronous `@@dispose` method will not be awaited and that any exception thrown will not be thrown synchronously.
              1. Return CreateBuiltinFunction(_closure_, 0, *""*, « »).
        1. Else,
          1. Let _method_ be ? GetMethod(_V_, @@dispose).
        1. Return _method_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-dispose" type="abstract operation">
      <h1>
        Dispose (
          _V_ : an Object or *undefined*,
          _hint_ : either ~sync-dispose~ or ~async-dispose~,
          _method_ : a function object or *undefined*,
        ): either a normal completion containing *undefined* or a throw completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If _method_ is *undefined*, let _result_ be *undefined*.
        1. Else, let _result_ be ? Call(_method_, _V_).
        1. If _hint_ is ~async-dispose~, then
          1. Perform ? Await(_result_).
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-disposeresources" type="abstract operation">
      <h1>
        DisposeResources (
          _disposeCapability_ : a DisposeCapability Record,
          _completion_ : a Completion Record,
        ): a Completion Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _needsAwait_ be *false*.
        1. Let _hasAwaited_ be *false*.
        1. For each element _resource_ of _disposeCapability_.[[DisposableResourceStack]], in reverse list order, do
          1. Let _value_ be _resource_.[[ResourceValue]].
          1. Let _hint_ be _resource_.[[Hint]].
          1. Let _method_ be _resource_.[[DisposeMethod]].
          1. If _hint_ is ~sync-dispose~ and _needsAwait_ is *true* and _hasAwaited_ is *false*, then
            1. Perform ! Await(*undefined*).
            1. Set _needsAwait_ to *false*.
          1. If _method_ is not *undefined*, then
            1. Let _result_ be Completion(Call(_method_, _value_)).
            1. If _result_ is a normal completion and _hint_ is ~async-dispose~, then
              1. Set _result_ to Completion(Await(_result_.[[Value]])).
              1. Set _hasAwaited_ to *true*.
            1. If _result_ is a throw completion, then
              1. If _completion_ is a throw completion, then
                1. Set _result_ to _result_.[[Value]].
                1. Let _suppressed_ be _completion_.[[Value]].
                1. Let _error_ be a newly created *SuppressedError* object.
                1. Perform CreateNonEnumerableDataPropertyOrThrow(_error_, *"error"*, _result_).
                1. Perform CreateNonEnumerableDataPropertyOrThrow(_error_, *"suppressed"*, _suppressed_).
                1. Set _completion_ to ThrowCompletion(_error_).
              1. Else,
                1. Set _completion_ to _result_.
          1. Else,
            1. Assert: _hint_ is ~async-dispose~.
            1. Set _needsAwait_ to *true*.
            1. NOTE: This can only indicate a case where either *null* or *undefined* was the initialized value of an `await using` declaration.
        1. If _needsAwait_ is *true* and _hasAwaited_ is *false*, then
          1. Perform ! Await(*undefined*).
        1. NOTE: After _disposeCapability_ has been disposed, it will never be used again. The contents of _disposeCapability_.[[DisposableResourceStack]] can be discarded in implementations, such as by garbage collection, at this point.
        1. Set _disposeCapability_.[[DisposableResourceStack]] to a new empty List.
        1. Return _completion_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>Syntax-Directed Operations</h1>
  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>Scope Analysis</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>Static Semantics: BoundNames ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* is used within this specification as a synthetic name for a module's default export when it does not have another name. An entry in the module's [[Environment]] is created with that name and holds the corresponding value, and resolving the export named *"default"* by calling <emu-xref href="#sec-resolveexport" title></emu-xref> for the module will return a ResolvedBinding Record whose [[BindingName]] is *"\*default\*"*, which will then resolve in the module's [[Environment]] to the above-mentioned value. This is done only for ease of specification, so that anonymous default exports can be resolved like any other export. The string *"\*default\*"* is never accessible to user code or to the module linking algorithm.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is the StringValue of |Identifier|.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. Return « *"yield"* ».
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. Return « *"await"* ».
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      <ins class="block">
      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`

        AwaitUsingDeclaration :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingList|.
      </emu-alg>
      </ins>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |BindingList|.
        1. Let _names2_ be the BoundNames of |LexicalBinding|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |VariableDeclarationList|.
        1. Let _names2_ be BoundNames of |VariableDeclaration|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingRestProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingRestElement|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElementList|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingRestElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingPropertyList|.
        1. Let _names2_ be BoundNames of |BindingProperty|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |BindingElementList|.
        1. Let _names2_ be BoundNames of |BindingElisionElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. Return BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingElement|.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingPattern|.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ForBinding|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FunctionRestParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _names1_ be BoundNames of |FormalParameterList|.
        1. Let _names2_ be BoundNames of |FormalParameter|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return the BoundNames of _formals_.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |BindingIdentifier|.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Return the BoundNames of _head_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportClause|.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NameSpaceImport|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.
        1. Let _names2_ be the BoundNames of |NamedImports|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |ImportsList|.
        1. Let _names2_ be the BoundNames of |ImportSpecifier|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |ImportedBinding|.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |VariableStatement|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. Return the BoundNames of |Declaration|.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.
        1. If _declarationNames_ does not include the element *"\*default\*"*, append *"\*default\*"* to _declarationNames_.
        1. Return _declarationNames_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. Return « *"\*default\*"* ».
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>Static Semantics: IsConstantDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return IsConstantDeclaration of |LetOrConst|.
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <ins class="block">
      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`

        AwaitUsingDeclaration :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      </ins>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>It is not necessary to treat `export default` |AssignmentExpression| as a constant declaration because there is no syntax that permits assignment to the internal bound name used to reference a module's default object.</p>
      </emu-note>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-static-semantics-isusingdeclaration" type="sdo">
      <h1>Static Semantics: IsUsingDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`

        AwaitUsingDeclaration :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ForDeclaration :
          `using` ForBinding
          `await` `using` ForBinding
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isawaitusingdeclaration" type="sdo">
      <h1>Static Semantics: IsAwaitUsingDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>UsingDeclaration : `using` BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>AwaitUsingDeclaration : CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ForDeclaration : `using` ForBinding</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ForDeclaration : `await` `using` ForBinding</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>Function Name Inference</h1>
    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>Static Semantics: IsFunctionDefinition ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return IsFunctionDefinition of _expr_.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          <del>AwaitExpression</del>
          <ins>CoverAwaitExpressionAndAwaitUsingDeclarationHead</ins>

        <ins class="block">
        AwaitExpression :
          `await` UnaryExpression
        </ins>

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        Runtime Semantics: IteratorBindingInitialization (
          _iteratorRecord_: an Iterator Record,
          _environment_: an Environment Record or *undefined*,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. If |Elision| is present, then
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
        1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_next_).
          1. If _next_ is *false*, then
            1. Set _iteratorRecord_.[[Done]] to *true*.
          1. Else,
            1. Set _v_ to Completion(IteratorValue(_next_)).
            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_v_).
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _defaultValue_ be ? Evaluation of |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
        1. Return ? InitializeReferencedBinding(_lhs_, _v_<ins>, ~normal~</ins>).
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. If _iteratorRecord_.[[Done]] is *false*, then
          1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
          1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_next_).
          1. If _next_ is *false*, then
            1. Set _iteratorRecord_.[[Done]] to *true*.
          1. Else,
            1. Set _v_ to Completion(IteratorValue(_next_)).
            1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_v_).
        1. If |Initializer| is present and _v_ is *undefined*, then
          1. Let _defaultValue_ be ? Evaluation of |Initializer|.
          1. Set _v_ to ? GetValue(_defaultValue_).
        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. If _iteratorRecord_.[[Done]] is *true*, then
            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).
            1. Return ? InitializeReferencedBinding(_lhs_, _A_<ins>, ~normal~</ins>).
          1. Let _nextValue_ be Completion(IteratorValue(_next_)).
          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_nextValue_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. Let _A_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. Repeat,
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.
          1. If _iteratorRecord_.[[Done]] is *true*, then
            1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.
          1. Let _nextValue_ be Completion(IteratorValue(_next_)).
          1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_nextValue_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _nextValue_).
          1. Set _n_ to _n_ + 1.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.
        1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, then
          1. Set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Set _v_ to Completion(IteratorValue(_next_)).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Let _v_ be *undefined*.
        1. Assert: _iteratorRecord_.[[Done]] is *false*.
        1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).
        1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
        1. ReturnIfAbrupt(_next_).
        1. If _next_ is *false*, then
          1. Set _iteratorRecord_.[[Done]] to *true*.
        1. Else,
          1. Set _v_ to Completion(IteratorValue(_next_)).
          1. If _v_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
          1. ReturnIfAbrupt(_v_).
        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>Static Semantics: AssignmentTargetType ( ): ~simple~ or ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is *"eval"* or *"arguments"*, return ~invalid~.
        1. Return ~simple~.
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return ~simple~.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return AssignmentTargetType of _expr_.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          SuperCall
          ImportCall
          CallExpression Arguments
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          <del>AwaitExpression</del>
          <ins>CoverAwaitExpressionAndAwaitUsingDeclarationHead</ins>

        <ins class="block">
        AwaitExpression :
          `await` UnaryExpression
        </ins>

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>
  <emu-clause id="sec-environment-records">
    <h1>Environment Records</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn> is a specification type used to define the association of |Identifier|s to specific variables and functions, based upon the lexical nesting structure of ECMAScript code. Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a |FunctionDeclaration|, a |BlockStatement|, or a |Catch| clause of a |TryStatement|. Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.</p>
    <p>Every Environment Record has an [[OuterEnv]] field, which is either *null* or a reference to an outer Environment Record. This is used to model the logical nesting of Environment Record values. The outer reference of an (inner) Environment Record is a reference to the Environment Record that logically surrounds the inner Environment Record. An outer Environment Record may, of course, have its own outer Environment Record. An Environment Record may serve as the outer environment for multiple inner Environment Records. For example, if a |FunctionDeclaration| contains two nested |FunctionDeclaration|s then the Environment Records of each of the nested functions will have as their outer Environment Record the Environment Record of the current evaluation of the surrounding function.</p>
    <p>Environment Records are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>The Environment Record Type Hierarchy</h1>
      <p>The Environment Record abstract class includes the abstract specification methods defined in <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Abstract Methods of Environment Records" oldids="table-15">
        <table>
          <tr>
            <th>
              Method
            </th>
            <th>
              Purpose
            </th>
          </tr>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Determine if an Environment Record has a binding for the String value _N_. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Create a new but uninitialized mutable binding in an Environment Record. The String value _N_ is the text of the bound name. If the Boolean argument _D_ is *true* the binding may be subsequently deleted.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Create a new but uninitialized immutable binding in an Environment Record. The String value _N_ is the text of the bound name. If _S_ is *true* then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V<ins>, _hint_</ins>)
            </td>
            <td>
              Set the value of an already existing but uninitialized binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type. <ins>_hint_ indicates whether the binding came from either a `using` declaration (~sync-dispose~), an `await using` declaration (~async-dispose~), or a regular variable declaration (~normal~).</ins>
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              Set the value of an already existing mutable binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is *true* and the binding cannot be set throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              Returns the value of an already existing binding from an Environment Record. The String value _N_ is the text of the bound name. _S_ is used to identify references originating in strict mode code or that otherwise require strict mode reference semantics. If _S_ is *true* and the binding does not exist throw a *ReferenceError* exception. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              Delete a binding from an Environment Record. The String value _N_ is the text of the bound name. If a binding for _N_ exists, remove the binding and return *true*. If the binding exists but cannot be removed return *false*. If the binding does not exist return *true*.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `this` binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `super` method binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              If this Environment Record is associated with a `with` statement, return the with object. Otherwise, return *undefined*.
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Records</h1>
        <p>Each <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn> is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A Declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.</p>
        <p><ins>Every Declarative Environment Record also has a [[DisposeCapability]] field, which contains a DisposeCapability Record. This field holds a stack of resources tracked by `using` declarations and `await using` declarations that must be disposed when the Evaluation step that constructed the Environment Record has completed.</ins></p>
        <p>The behaviour of the concrete specification methods for Declarative Environment Records is defined by the following algorithms.</p>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~,</ins>
            ): a normal completion containing ~unused~
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is _N_ to the value _V_. An uninitialized binding for _N_ must already exist.</dd>
          </dl>
          <emu-alg>
            1. Assert: _envRec_ must have an uninitialized binding for _N_.
            1. <ins>If _hint_ is not ~normal~, perform ? AddDisposableResource(_envRec_.[[DisposeCapability]], _V_, _hint_).</ins>
            1. Set the bound value for _N_ in _envRec_ to _V_.
            1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Records</h1>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~,</ins>
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_.</dd>
          </dl>
          <emu-alg>
            1. <ins>Assert: _hint_ is ~normal~.</ins>
            1. Perform ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*).
            1. Return ~unused~.
          </emu-alg>
          <emu-note>
            <p>In this specification, all uses of CreateMutableBinding for object Environment Records are immediately followed by a call to InitializeBinding for the same name. Hence, this specification does not explicitly track the initialization state of bindings in object Environment Records.</p>
          </emu-note>
        </emu-clause>

      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>Global Environment Records</h1>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: a String,
              _V_: an ECMAScript language value,
              <ins>_hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~,</ins>
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>It is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. An uninitialized binding for _N_ must already exist.</dd>
          </dl>
          <emu-alg>
            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].
            1. If ! _DclRec_.HasBinding(_N_) is *true*, then
              1. Return ! _DclRec_.InitializeBinding(_N_, _V_<ins>, _hint_</ins>).
            1. Assert: If the binding exists, it must be in the object Environment Record.
            1. <ins>Assert: _hint_ is ~normal~.</ins>
            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].
            1. Return ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_<ins>, ~normal~</ins>).
          </emu-alg>
        </emu-clause>

      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations">
      <h1>Environment Record Operations</h1>
      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: an Environment Record or *null*,
          ): a Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _env_ be a new Declarative Environment Record containing no bindings.
          1. Set _env_.[[OuterEnv]] to _E_.
          1. <ins>Set _env_.[[DisposeCapability]] to NewDisposeCapability().</ins>
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: an ECMAScript function,
            _newTarget_: an Object or *undefined*,
          ): a Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _env_ be a new Function Environment Record containing no bindings.
          1. Set _env_.[[FunctionObject]] to _F_.
          1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.
          1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.
          1. Set _env_.[[NewTarget]] to _newTarget_.
          1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].
          1. <ins>Set _env_.[[DisposeCapability]] to NewDisposeCapability().</ins>
          1. Return _env_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: an Environment Record,
          ): a Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _env_ be a new Module Environment Record containing no bindings.
          1. Set _env_.[[OuterEnv]] to _E_.
          1. <ins>Set _env_.[[DisposeCapability]] to NewDisposeCapability().</ins>
          1. Return _env_.
        </emu-alg>
      </emu-clause>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>
  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>
    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing ~unused~ or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ is the function object for which the execution context is being established.</dd>
      </dl>
      <emu-note>
        <p>When an execution context is established for evaluating an ECMAScript function a new Function Environment Record is created and bindings for each formal parameter are instantiated in that Environment Record. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-functiondeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _calleeContext_ be the running execution context.
        1. Let _code_ be _func_.[[ECMAScriptCode]].
        1. Let _strict_ be _func_.[[Strict]].
        1. Let _formals_ be _func_.[[FormalParameters]].
        1. Let _parameterNames_ be the BoundNames of _formals_.
        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.
        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.
        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.
        1. Let _varNames_ be the VarDeclaredNames of _code_.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.
        1. Let _functionNames_ be a new empty List.
        1. Let _functionsToInitialize_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _functionNames_ does not contain _fn_, then
              1. Insert _fn_ as the first element of _functionNames_.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _argumentsObjectNeeded_ be *true*.
        1. If _func_.[[ThisMode]] is ~lexical~, then
          1. NOTE: Arrow functions never have an arguments object.
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if _parameterNames_ contains *"arguments"*, then
          1. Set _argumentsObjectNeeded_ to *false*.
        1. Else if _hasParameterExpressions_ is *false*, then
          1. If _functionNames_ contains *"arguments"* or _lexicalNames_ contains *"arguments"*, then
            1. Set _argumentsObjectNeeded_ to *false*.
        1. If _strict_ is *true* or _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.
          1. Let _env_ be the LexicalEnvironment of _calleeContext_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.
          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.
          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).
          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.
          1. Set the LexicalEnvironment of _calleeContext_ to _env_.
        1. For each String _paramName_ of _parameterNames_, do
          1. Let _alreadyDeclared_ be ! _env_.HasBinding(_paramName_).
          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
          1. If _alreadyDeclared_ is *false*, then
            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).
            1. If _hasDuplicates_ is *true*, then
              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*<ins>, ~normal~</ins>).
        1. If _argumentsObjectNeeded_ is *true*, then
          1. If _strict_ is *true* or _simpleParameterList_ is *false*, then
            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).
          1. Else,
            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).
          1. If _strict_ is *true*, then
            1. Perform ! _env_.CreateImmutableBinding(*"arguments"*, *false*).
            1. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.
          1. Else,
            1. Perform ! _env_.CreateMutableBinding(*"arguments"*, *false*).
          1. Perform ! _env_.InitializeBinding(*"arguments"*, _ao_<ins>, ~normal~</ins>).
          1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and « *"arguments"* ».
        1. Else,
          1. Let _parameterBindings_ be _parameterNames_.
        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).
        1. If _hasDuplicates_ is *true*, then
          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and *undefined*.
        1. Else,
          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _env_.
        1. If _hasParameterExpressions_ is *false*, then
          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.
          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.
          1. For each element _n_ of _varNames_, do
            1. If _instantiatedVarNames_ does not contain _n_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).
              1. Perform ! _env_.InitializeBinding(_n_, *undefined*<ins>, ~normal~</ins>).
          1. Let _varEnv_ be _env_.
        1. Else,
          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).
          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.
          1. Let _instantiatedVarNames_ be a new empty List.
          1. For each element _n_ of _varNames_, do
            1. If _instantiatedVarNames_ does not contain _n_, then
              1. Append _n_ to _instantiatedVarNames_.
              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).
              1. If _parameterBindings_ does not contain _n_, or if _functionNames_ contains _n_, then
                1. Let _initialValue_ be *undefined*.
              1. Else,
                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).
              1. Perform ! _varEnv_.InitializeBinding(_n_, _initialValue_<ins>, ~normal~</ins>).
              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
        1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-functiondeclarationinstantiation"></emu-xref> adds additional steps at this point.
        1. If _strict_ is *false*, then
          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).
          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
        1. Else,
          1. Let _lexEnv_ be _varEnv_.
        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).
        1. Let _privateEnv_ be the PrivateEnvironment of _calleeContext_.
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>
  <emu-clause id="sec-unary-operators">
    <h1>Unary Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        <del>[+Await] AwaitExpression[?Yield]</del>
        <ins>[+Await] CoverAwaitExpressionAndAwaitUsingDeclarationHead[?Yield]</ins>

      <ins class="block">
        CoverAwaitExpressionAndAwaitUsingDeclarationHead[Yield] :
          `await` UnaryExpression[?Yield, +Await]
      </ins>
    </emu-grammar>
    <ins class="block">
    <h2>Supplemental Syntax</h2>
    <p>
      When processing an instance of the production<br>
      <emu-grammar>UnaryExpression : CoverAwaitExpressionAndAwaitUsingDeclarationHead</emu-grammar><br>
      the interpretation of |CoverAwaitExpressionAndAwaitUsingDeclarationHead| is refined using the following grammar:
    </p>
    <emu-grammar>
      AwaitExpression[?Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript Language: Statements and Declarations</h1>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <emu-clause id="sec-block-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _blockValue_ be Completion(Evaluation of |StatementList|).
        1. <ins>Set _blockValue_ to Completion(DisposeResources(_blockEnv_.[[DisposeCapability]], _blockValue_)).</ins>
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return ? _blockValue_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ is the Parse Node corresponding to the body of the block. _env_ is the Environment Record in which bindings are to be created.</dd>
      </dl>
      <emu-note>
        <p>When a |Block| or |CaseBlock| is evaluated a new Declarative Environment Record is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the Environment Record.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <!--
        WARNING: If you add, remove, rename, or repurpose any variable names
                 within this algorithm, you may need to update
                 #sec-web-compat-blockdeclarationinstantiation accordingly.
      -->
      <emu-alg>
        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. For each element _d_ of _declarations_, do
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. [id="step-blockdeclarationinstantiation-createmutablebinding"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
          1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
            1. [id="step-blockdeclarationinstantiation-initializebinding"] Perform ! _env_.InitializeBinding(_fn_, _fo_<ins>, ~normal~</ins>). NOTE: This step is replaced in section <emu-xref href="#sec-web-compat-blockdeclarationinstantiation"></emu-xref>.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>Declarations and the Variable Statement</h1>
    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let<del> and Const</del><ins>, Const, Using, and Await Using</ins> Declarations</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await, <ins>+Pattern</ins>] `;`
          <ins>UsingDeclaration[?In, ?Yield, ?Await]</ins>
          <ins>[+Await] AwaitUsingDeclaration[?In, ?Yield]</ins>

        LetOrConst :
          `let`
          `const`

        <ins class="block">
        UsingDeclaration[In, Yield, Await] :
          `using` [no LineTerminator here] BindingList[?In, ?Yield, ?Await, ~Pattern] `;`

        AwaitUsingDeclaration[In, Yield] :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead[?Yield] [no LineTerminator here] BindingList[?In, ?Yield, ?Await, ~Pattern] `;`
        </ins>

        BindingList[In, Yield, Await, <ins>Pattern</ins>] :
          LexicalBinding[?In, ?Yield, ?Await, <ins>?Pattern</ins>]
          BindingList[?In, ?Yield, ?Await, <ins>?Pattern</ins>] `,` LexicalBinding[?In, ?Yield, ?Await, <ins>?Pattern</ins>]

        LexicalBinding[In, Yield, Await, <ins>Pattern</ins>] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          <del>BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</del>
          <ins>[+Pattern] BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]</ins>
      </emu-grammar>

      <ins class="block">
      <h2>Supplemental Syntax</h2>
      <p>
        When processing an instance of the production<br>
        <emu-grammar>AwaitUsingDeclaration : CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`</emu-grammar><br>
        the interpretation of |CoverAwaitExpressionAndAwaitUsingDeclarationHead| is refined using the following grammar:
      </p>
      <emu-grammar type="definition">
        AwaitUsingDeclarationHead :
          `await` [no LineTerminator here] `using`
        </emu-grammar>
      </ins>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <ins class="block">
        <emu-grammar>
          UsingDeclaration :
            `using` BindingList `;`
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains *"let"*.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if the goal symbol is |Script| and |UsingDeclaration| is not contained, either directly or indirectly, within a |Block|, |CaseBlock|, |ForStatement|, |ForInOfStatement|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, or |ClassStaticBlockBody|.
          </li>
        </ul>
        <emu-grammar>
          AwaitUsingDeclaration :
            CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
        </emu-grammar>
        <ul>
          <li>|CoverAwaitExpressionAndAwaitUsingDeclarationHead| must cover an |AwaitUsingDeclarationHead|.</li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains *"let"*.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if the goal symbol is |Script| and |AwaitUsingDeclaration| is not contained, either directly or indirectly, within a |Block|, |CaseBlock|, |ForStatement|, |ForInOfStatement|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, or |ClassStaticBlockBody|.
          </li>
        </ul>
        <emu-note>
          Draft Note: This behavior is currently under discussion in <a href="https://github.com/tc39/proposal-explicit-resource-management/issues/66">#66</a>. The above boundaries have been chosen for the following reasons:
          <ul>
            <li>
              |Block|, |CaseBlock|, |FunctionBody|, |GeneratorBody|, |AsyncGeneratorBody|, |AsyncFunctionBody|, |ClassStaticBlockBody|, and |ClassBody| each introduce an explicit block scope.
            </li>
            <li>
              |ForStatement| introduces an implicit block scope for the entire statement.
            </li>
            <li>
              |ForInOfStatement| introduces an implicit block scope per iteration.
            </li>
          </ul>
        </emu-note>
        </ins>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Perform ? <del>Evaluation</del><ins>BindingEvaluation</ins> of |BindingList|<ins> with argument ~normal~</ins>.
          1. Return ~empty~.
        </emu-alg>

        <ins class="block">
        <emu-grammar>UsingDeclaration : `using` BindingList `;`</emu-grammar>
        <emu-alg>
          1. Perform ? BindingEvaluation of |BindingList| with argument ~sync-dispose~.
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>AwaitUsingDeclaration : CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`</emu-grammar>
        <emu-alg>
          1. Perform ? BindingEvaluation of |BindingList| with argument ~async-dispose~.
          1. Return ~empty~.
        </emu-alg>
        </ins>

        <del class="block">
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |BindingList|.
          1. Return ? Evaluation of |LexicalBinding|.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).
          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*).
          1. Return ~empty~.
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ! ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Perform ! InitializeReferencedBinding(_lhs_, _value_).
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.
        </emu-alg>
        </del>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-bindingevaluation" type="sdo">
        <h1>
          Runtime Semantics: BindingEvaluation (
            _hint_: one of ~normal~, ~sync-dispose~, or ~async-dispose~.
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Perform ? BindingEvaluation of |BindingList| with argument _hint_.
          1. Perform ? BindingEvaluation of |LexicalBinding| with argument _hint_.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).
          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*, ~normal~).
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const`, `using`, or `await using` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ! ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be the ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Perform ! InitializeReferencedBinding(_lhs_, _value_, _hint_).
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Assert: _hint_ is ~normal~.
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.
        </emu-alg>
      </emu-clause>
      </ins>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>Destructuring Binding Patterns</h1>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: RestBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
            _excludedNames_: a List of property keys,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _restObj_).
          1. Return ? InitializeReferencedBinding(_lhs_, _restObj_<ins>, ~normal~</ins>).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: KeyedBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
            _propertyName_: a property key,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be ? Evaluation of |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return ? InitializeReferencedBinding(_lhs_, _v_<ins>, ~normal~</ins>).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>

    <emu-clause id="sec-for-statement">
      <h1>The `for` Statement</h1>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: ForLoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. If the first |Expression| is present, then
            1. Let _exprRef_ be ? Evaluation of the first |Expression|.
            1. Perform ? GetValue(_exprRef_).
          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.
          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.
          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |VariableDeclarationList|.
          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.
          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.
          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).
          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.
          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.
          1. For each element _dn_ of _boundNames_, do
            1. If _isConst_ is *true*, then
              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).
          1. Set the running execution context's LexicalEnvironment to _loopEnv_.
          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).
          1. If _forDcl_ is an abrupt completion, then
            1. <ins>Set _forDcl_ to Completion(DisposeResources(_loopEnv_.[[DisposeCapability]], _forDcl_)).</ins>
            1. <ins>Assert: _forDcl_ is an abrupt completion.</ins>
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. Return ? _forDcl_.
          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.
          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.
          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.
          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).
          1. <ins>Set _bodyResult_ to Completion(DisposeResources(_loopEnv_.[[DisposeCapability]], _bodyResult_)).</ins>
          1. <ins>Assert: If _bodyResult_.[[Type]] is ~normal~, then _bodyResult_.[[Value]] is not ~empty~.</ins>
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return ? _bodyResult_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>The `for-in`, `for-of`, and `for-await-of` Statements</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await, <ins>+Pattern</ins>] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await, <ins>~Using</ins>] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; {`let`, `async` `of`}] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await, <ins>+Pattern</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` <ins>[lookahead != `using` `of`]</ins> ForDeclaration[?Yield, ?Await, <ins>+Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await, <ins>+Pattern</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` <ins>[lookahead != `using` `of`]</ins> ForDeclaration[?Yield, ?Await, <ins>+Using</ins>] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await, <ins>Using</ins>] :
          LetOrConst ForBinding[?Yield, ?Await, <ins>+Pattern</ins>]
          <ins>[+Using] `using` [no LineTerminator here] ForBinding[?Yield, ?Await, ~Pattern]</ins>
          <ins>[+Using, +Await] `await` [no LineTerminator here] `using` [no LineTerminator here] ForBinding[?Yield, +Await, ~Pattern]</ins>

        ForBinding[Yield, Await, <ins>Pattern</ins>] :
          BindingIdentifier[?Yield, ?Await]
          <del>BindingPattern[?Yield, ?Await]</del>
          <ins>[+Pattern] BindingPattern[?Yield, ?Await]</ins>
      </emu-grammar>
      <emu-note>
        <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          Runtime Semantics: ForDeclarationBindingInstantiation (
            _environment_: a Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. If IsConstantDeclaration of |LetOrConst| is *true*, then
              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).
            1. Else,
              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).
        </emu-alg>
        <ins class="block">
        <emu-grammar>
          ForDeclaration :
            `using` ForBinding
            `await` `using` ForBinding
        </emu-grammar>
        <emu-alg>
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: a Parse Node,
            _stmt_: a |Statement| Parse Node,
            _iteratorRecord_: an Iterator Record,
            _iterationKind_: ~enumerate~ or ~iterate~,
            _lhsKind_: ~assignment~, ~varBinding~, or ~lexicalBinding~,
            _labelSet_: a List of Strings,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _V_ be *undefined*.
          1. <ins>If IsAwaitUsingDeclaration of _lhs_ is *true*, then</ins>
            1. <ins>Let _hint_ be ~async-dispose~.</ins>
          1. <ins>Else, if IsUsingDeclaration of _lhs_ is *true*, then</ins>
            1. <ins>Let _hint_ be ~sync-dispose~.</ins>
          1. <ins>Else, </ins>
            1. <ins>Let _hint_ be ~normal~.</ins>
          1. Let _destructuring_ be IsDestructuring of _lhs_.
          1. If _destructuring_ is *true* and _lhsKind_ is ~assignment~, then
            1. Assert: _lhs_ is a |LeftHandSideExpression|.
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.
          1. Repeat,
            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).
            1. If _nextResult_ is not an Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_nextResult_).
            1. If _done_ is *true*, return _V_.
            1. Let _nextValue_ be ? IteratorValue(_nextResult_).
            1. If _lhsKind_ is either ~assignment~ or ~varBinding~, then
              1. If _destructuring_ is *true*, then
                1. If _lhsKind_ is ~assignment~, then
                  1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).
                1. Else,
                  1. Assert: _lhsKind_ is ~varBinding~.
                  1. Assert: _lhs_ is a |ForBinding|.
                  1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).
              1. Else,
                1. Let _lhsRef_ be Completion(Evaluation of _lhs_). (It may be evaluated repeatedly.)
                1. If _lhsRef_ is an abrupt completion, then
                  1. Let _status_ be _lhsRef_.
                1. Else,
                  1. Let _status_ be Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)).
              1. <ins>Let _iterationEnv_ be *undefined*.</ins>
            1. Else,
              1. Assert: _lhsKind_ is ~lexicalBinding~.
              1. Assert: _lhs_ is a |ForDeclaration|.
              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).
              1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.
              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.
              1. If _destructuring_ is *true*, then
                1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).
              1. Else,
                1. Assert: _lhs_ binds a single name.
                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.
                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).
                1. <del>Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).</del>
                1. <ins>Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_, _hint_)).</ins>
            1. If _status_ is an abrupt completion, then
              1. <ins>If _iterationEnv_ is not *undefined*, then</ins>
                1. <ins>Set _status_ to Completion(DisposeResources(_iterationEnv_.[[DisposeCapability]], _status_)).</ins>
                1. <ins>Assert: _status_ is an abrupt completion.</ins>
              1. Set the running execution context's LexicalEnvironment to _oldEnv_.
              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? _status_.
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. Let _result_ be Completion(Evaluation of _stmt_).
            1. <ins>If _iterationEnv_ is not *undefined*, then</ins>
              1. <ins>Set _result_ to Completion(DisposeResources(_iterationEnv_.[[DisposeCapability]], _result_)).</ins>
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. If LoopContinues(_result_, _labelSet_) is *false*, then
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? UpdateEmpty(_result_, _V_).
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).
                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>The `switch` Statement</h1>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _switchValue_ be ? GetValue(_exprRef_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).
        1. <ins>Set _R_ to Completion(DisposeResources(_blockEnv_.[[DisposeCapability]], _R_)).</ins>
        1. <ins>Assert: If _R_.[[Type]] is ~normal~, then _R_.[[Value]] is not ~empty~.</ins>
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _R_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |SwitchStatement| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>

  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateOrdinaryFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): a function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |FunctionExpression| can be referenced from inside the |FunctionExpression|'s |FunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |FunctionExpression| cannot be referenced from and does not affect the scope enclosing the |FunctionExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-note>
        <p>An alternative semantics is provided in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.
      </emu-alg>
      <emu-note>
        <p>A *"prototype"* property is automatically created for every function defined using a |FunctionDeclaration| or |FunctionExpression|, to allow for the possibility that the function will be used as a constructor.</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return *undefined*.
      </emu-alg>
      <ins class="block">
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. Let _result_ be Completion(Evaluation of |StatementList|).
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Assert: _env_ is a Declarative Environment Record.
        1. Return ? DisposeResources(_env_.[[DisposeCapability]], _result_).
      </emu-alg>
      </ins>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateGeneratorFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): a function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |GeneratorExpression| can be referenced from inside the |GeneratorExpression|'s |FunctionBody| to allow the generator code to call itself recursively. However, unlike in a |GeneratorDeclaration|, the |BindingIdentifier| in a |GeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |GeneratorExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): a function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncGeneratorExpression| can be referenced from inside the |AsyncGeneratorExpression|'s |AsyncGeneratorBody| to allow the generator code to call itself recursively. However, unlike in an |AsyncGeneratorDeclaration|, the |BindingIdentifier| in an |AsyncGeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncGeneratorExpression|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateClassStaticBlockBody (
          _functionObject_: a function object,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, « »).
        1. <del>Return ? Evaluation of |ClassStaticBlockStatementList|.</del>
        1. <ins>Let _result_ be Completion(Evaluation of |ClassStaticBlockStatementList|).</ins>
        1. <ins>Let _env_ be the running execution context's LexicalEnvironment.</ins>
        1. <ins>Return ? DisposeResources(_env_.[[DisposeCapability]], _result_).</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: a String or *undefined*,
          _className_: a property key or a Private Name,
        ): either a normal completion containing a function object or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>
        <p>For example, an implementation could directly associate instance private methods with their corresponding Private Name and track, for each object, which class constructors have run with that object as their `this` value. Looking up an instance private method on an object then consists of checking that the class constructor which defines the method has been used to initialize the object, then returning the method associated with the Private Name.</p>
        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |ClassBody?| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody?|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage?| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classEnv_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(? _superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, then
            1. Throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody?| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classEnv_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If _constructor_ is ~empty~, then
          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
            1. If NewTarget is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be the active function object.
            1. If _F_.[[ConstructorKind]] is ~derived~, then
              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.
              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().
              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).
            1. Else,
              1. NOTE: This branch behaves similarly to `constructor() {}`.
              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
            1. Perform ? InitializeInstanceElements(_result_, _F_).
            1. Return _result_.
          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform MakeClassConstructor(_F_).
          1. Perform SetFunctionName(_F_, _className_).
        1. Perform MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage?| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform CreateMethodProperty(_proto_, *"constructor"*, _F_).
        1. If |ClassBody?| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).
          1. Else,
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _element_.
          1. Set _element_ to _element_.[[Value]].
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then
              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.
              1. Replace _pe_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_<ins>, ~normal~</ins>).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Return _F_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async Function Definitions</h1>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <ins class="block">
        <emu-grammar>
          UnaryExpression : CoverAwaitExpressionAndAwaitUsingDeclarationHead
        </emu-grammar>
        <ul>
          <li>|CoverAwaitExpressionAndAwaitUsingDeclarationHead| must cover an |AwaitExpression|.</li>
        </ul>
      </ins>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): a function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the LexicalEnvironment of the running execution context.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_<ins>, ~normal~</ins>).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncFunctionExpression| can be referenced from inside the |AsyncFunctionExpression|'s |AsyncFunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |AsyncFunctionExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncFunctionExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <ins class="block">
      <emu-grammar>
        UnaryExpression : CoverAwaitExpressionAndAwaitUsingDeclarationHead
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |AwaitExpression| that is covered by |CoverAwaitExpressionAndAwaitUsingDeclarationHead|.
        1. Return ? Evaluation of _expr_.
      </emu-alg>
      </ins>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>Tail Position Calls</h1>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        Static Semantics: HasCallInTailPosition (
          _call_: a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_ is a Parse Node that represents a specific range of source text. When the following algorithms compare _call_ to another Parse Node, it is a test of whether they represent the same source text.</p>
      </emu-note>
      <emu-note>
        <p>A potential tail position call that is immediately followed by return GetValue of the call result is also a possible tail position call. A function call cannot return a Reference Record, so such a GetValue operation will always return the same value as the actual function call result.</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. <ins>If HasUnterminatedUsingDeclaration of |StatementList| is *true*, return *false*.</ins>
        1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of the second |Statement| with argument _call_.
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Statement| with argument _call_.
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Expression| with argument _call_.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. Let _has_ be *false*.
        1. <del>If the first |CaseClauses| is present, let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.</del>
        1. <del>If _has_ is *true*, return *true*.</del>
        1. <ins>If the first |CaseClauses| is present, then</ins>
          1. <ins>Let _has_ be HasCallInTailPosition of the first |CaseClauses| with argument _call_.</ins>
          1. <ins>If _has_ is *true*, return *true*.</ins>
          1. <ins>If HasUnterminatedUsingDeclaration of the first |CaseClauses| is *true*, return *false*.</ins>
        1. Let _has_ be HasCallInTailPosition of |DefaultClause| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. <ins>If HasUnterminatedUsingDeclaration of |DefaultClause| is *true*, return *false*.</ins>
        1. If the second |CaseClauses| is present, let _has_ be HasCallInTailPosition of the second |CaseClauses| with argument _call_.
        1. Return _has_.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. <ins>If HasUnterminatedUsingDeclaration of |CaseClauses| is *true*, return *false*.</ins>
        1. Return HasCallInTailPosition of |CaseClause| with argument _call_.
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Catch| with argument _call_.
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Finally| with argument _call_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Block| with argument _call_.
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          <del>AwaitExpression</del>
          <ins>CoverAwaitExpressionAndAwaitUsingDeclarationHead</ins>

        <ins class="block">
        AwaitExpression :
          `await` UnaryExpression
        </ins>

        CallExpression :
          SuperCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. If this |CallExpression| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. If this |OptionalChain| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. If this |MemberExpression| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return HasCallInTailPosition of _expr_ with argument _call_.
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Expression| with argument _call_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-static-semantics-hasunterminatedusingdeclaration" type="sdo">
      <h1>Static Semantics: HasUnterminatedUsingDeclaration ( ): a Boolean</h1>
      <dl class="header">
      </dl>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasUnterminatedUsingDeclaration of |StatementList|.
        1. If _has_ is *true*, return *true*.
        1. Return HasUnterminatedUsingDeclaration of |StatementListItem|.
      </emu-alg>

      <emu-grammar>
        StatementListItem :
          Statement

        CaseBlock :
          `{` `}`

        Declaration :
          HoistableDeclaration
          ClassDeclaration

        LexicalDeclaration :
          LetOrConst BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        UsingDeclaration :
          `using` BindingList `;`

        AwaitUsingDeclaration :
          CoverAwaitExpressionAndAwaitUsingDeclarationHead BindingList `;`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>

      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasUnterminatedUsingDeclaration of |CaseClauses|.
        1. If _has_ is *true*, return *true*.
        1. Return HasUnterminatedUsingDeclaration of |CaseClause| with argument _call_.
      </emu-alg>

      <emu-grammar>
        CaseClause :
          `case` Expression `:` StatementList?

        DefaultClause :
          `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. If |StatementList| is present, return HasUnterminatedUsingDeclaration of |StatementList|.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_, <ins>~normal~</ins>).
              1. Else,
                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_, <ins>~normal~</ins>).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _declaredVarNames_ does not contain _dn_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*, <ins>~normal~</ins>).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_, <ins>~normal~</ins>).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
          <h1>
            ExecuteModule (
              optional _capability_: unknown,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.
            1. Let _env_ be _module_.[[Environment]].
            1. Set the VariableEnvironment of _moduleContext_ to _env_.
            1. Set the LexicalEnvironment of _moduleContext_ to _env_.
            1. Suspend the running execution context.
            1. If _module_.[[HasTLA]] is *false*, then
              1. Assert: _capability_ is not present.
              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
              1. Let _result_ be Completion(Evaluation of _module_.[[ECMAScriptCode]]).
              1. <ins>Set _result_ to Completion(DisposeResources(_env_.[[DisposeCapability]], _result_)).</ins>
              1. Suspend _moduleContext_ and remove it from the execution context stack.
              1. Resume the context that is now on the top of the execution context stack as the running execution context.
              1. If _result_ is an abrupt completion, then
                1. Return ? _result_.
            1. Else,
              1. Assert: _capability_ is a PromiseCapability Record.
              1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-exports">
        <h1>Exports</h1>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          ExportDeclaration :
            `export` ExportFromClause FromClause `;`
            `export` NamedExports `;`
            `export` VariableStatement[~Yield, +Await]
            `export` <ins>[lookahead &notin; { `using`, `await` }]</ins> Declaration[~Yield, +Await]
            `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
            `export` `default` ClassDeclaration[~Yield, +Await, +Default]
            `export` `default` [lookahead &notin; {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, +Await] `;`

          ExportFromClause :
            `*`
            `*` `as` IdentifierName
            NamedExports

          NamedExports :
            `{` `}`
            `{` ExportsList `}`
            `{` ExportsList `,` `}`

          ExportsList :
            ExportSpecifier
            ExportsList `,` ExportSpecifier

          ExportSpecifier :
            IdentifierName
            IdentifierName `as` IdentifierName
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>The Global Object</h1>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>Function Properties of the Global Object</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: a |ScriptBody| Parse Node,
            _varEnv_: an Environment Record,
            _lexEnv_: a Declarative Environment Record,
            _privateEnv_: a PrivateEnvironment Record or *null*,
            _strict_: a Boolean,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <!--
          WARNING: If you add, remove, rename, or repurpose any variable names
                   within this algorithm, you may need to update
                   #sec-web-compat-evaldeclarationinstantiation and
                   #sec-variablestatements-in-catch-blocks accordingly.
        -->
        <emu-alg>
          1. Let _varNames_ be the VarDeclaredNames of _body_.
          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.
          1. If _strict_ is *false*, then
            1. If _varEnv_ is a Global Environment Record, then
              1. For each element _name_ of _varNames_, do
                1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.
            1. Let _thisEnv_ be _lexEnv_.
            1. Assert: The following loop will terminate.
            1. Repeat, while _thisEnv_ is not _varEnv_,
              1. If _thisEnv_ is not an Object Environment Record, then
                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
                1. For each element _name_ of _varNames_, do
                  1. If ! _thisEnv_.HasBinding(_name_) is *true*, then
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding"] Throw a *SyntaxError* exception.
                    1. NOTE: Annex <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref> defines alternate semantics for the above step.
                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].
          1. Let _privateIdentifiers_ be a new empty List.
          1. Let _pointer_ be _privateEnv_.
          1. Repeat, while _pointer_ is not *null*,
            1. For each Private Name _binding_ of _pointer_.[[Names]], do
              1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.
            1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].
          1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.
          1. Let _functionsToInitialize_ be a new empty List.
          1. Let _declaredFunctionNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, in reverse List order, do
            1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Let _fn_ be the sole element of the BoundNames of _d_.
              1. If _declaredFunctionNames_ does not contain _fn_, then
                1. If _varEnv_ is a Global Environment Record, then
                  1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).
                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
                1. Append _fn_ to _declaredFunctionNames_.
                1. Insert _d_ as the first element of _functionsToInitialize_.
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point"] NOTE: Annex <emu-xref href="#sec-web-compat-evaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
          1. Let _declaredVarNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, do
            1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. For each String _vn_ of the BoundNames of _d_, do
                1. If _declaredFunctionNames_ does not contain _vn_, then
                  1. If _varEnv_ is a Global Environment Record, then
                    1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).
                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                  1. If _declaredVarNames_ does not contain _vn_, then
                    1. Append _vn_ to _declaredVarNames_.
          1. [id="step-evaldeclarationinstantiation-post-validation"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a Global Environment Record and the global object is a Proxy exotic object.
          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.
          1. For each element _d_ of _lexDeclarations_, do
            1. NOTE: Lexically declared names are only instantiated here but not initialized.
            1. For each element _dn_ of the BoundNames of _d_, do
              1. If IsConstantDeclaration of _d_ is *true*, then
                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).
              1. Else,
                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).
          1. For each Parse Node _f_ of _functionsToInitialize_, do
            1. Let _fn_ be the sole element of the BoundNames of _f_.
            1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
            1. If _varEnv_ is a Global Environment Record, then
              1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).
            1. Else,
              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_fn_).
              1. If _bindingExists_ is *false*, then
                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.CreateMutableBinding(_fn_, *true*).
                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_, <ins>~normal~</ins>).
              1. Else,
                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
          1. For each String _vn_ of _declaredVarNames_, do
            1. If _varEnv_ is a Global Environment Record, then
              1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).
            1. Else,
              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_vn_).
              1. If _bindingExists_ is *false*, then
                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.CreateMutableBinding(_vn_, *true*).
                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*, <ins>~normal~</ins>).
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>An alternative version of this algorithm is described in <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>Fundamental Objects</h1>

  <emu-clause id="sec-error-objects">
    <h1>Error Objects</h1>
    <p>Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.</p>
    <p>When an ECMAScript implementation detects a runtime error, it throws a new instance of one of the _NativeError_ objects defined in <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> or a new instance of <ins>either the</ins> AggregateError object defined in <emu-xref href="#sec-aggregate-error-objects"></emu-xref><ins>, or the SuppressedError object defined in <emu-xref href="#sec-suppressederror-objects"></emu-xref></ins>. Each of these objects has the structure described below, differing only in the name used as the constructor name instead of _NativeError_, in the *"name"* property of the prototype object, in the implementation-defined *"message"* property of the prototype object, and in <ins>either</ins> the presence of the %AggregateError%-specific *"errors"* property<ins> or the %SuppressedError%-specific *"error"* and *"suppressed"* properties</ins>.</p>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Properties of Error Instances</h1>
      <p>Error instances are ordinary objects that inherit properties from the Error prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified uses of [[ErrorData]] is to identify Error, AggregateError, <ins>SuppressedError,</ins> and _NativeError_ instances as Error objects within `Object.prototype.toString`.</p>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ Object Structure</h1>
      <p>When an ECMAScript implementation detects a runtime error, it throws a new instance of one of the _NativeError_ objects defined in <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref>. Each of these objects has the structure described below, differing only in the name used as the constructor name instead of _NativeError_, in the *"name"* property of the prototype object, and in the implementation-defined *"message"* property of the prototype object.</p>
      <p>For each error object, references to _NativeError_ in the definition should be replaced with the appropriate error object name from <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref>.</p>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>Properties of _NativeError_ Instances</h1>
        <p>_NativeError_ instances are ordinary objects that inherit properties from their _NativeError_ prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) to identify Error, AggregateError, <ins>SuppressedError,</ins> or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError Objects</h1>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>Properties of AggregateError Instances</h1>
        <p>AggregateError instances are ordinary objects that inherit properties from their AggregateError prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) to identify Error, AggregateError, <ins>SuppressedError,</ins> or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-suppressederror-objects">
      <h1>SuppressedError Objects</h1>

      <emu-clause id="sec-suppressederror-constructor">
        <h1>The SuppressedError Constructor</h1>
        <p>The SuppressedError constructor:</p>
        <ul>
          <li>is <dfn>%SuppressedError%</dfn>.</li>
          <li>is the initial value of the *"SuppressedError"* property of the global object.</li>
          <li>creates and initializes a new SuppressedError object when called as a function rather than as a constructor. Thus the function call `SuppressedError(…)` is equivalent to the object creation expression `new SuppressedError(…)` with the same arguments.</li>
          <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SuppressedError behaviour must include a `super` call to the SuppressedError constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
        </ul>

        <emu-clause id="sec-suppressederror">
          <h1>SuppressedError ( _error_, _suppressed_, _message_ )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%SuppressedError.prototype%"*, « [[ErrorData]] »).
            1. If _message_ is not *undefined*, then
              1. Let _messageString_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _messageString_).
            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"error"*, _error_).
            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"suppressed"*, _suppressed_).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-suppressederror-constructors">
        <h1>Properties of the SuppressedError Constructor</h1>
        <p>The SuppressedError constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is %Error%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-suppressederror.prototype">
          <h1>SuppressedError.prototype</h1>
          <p>The initial value of `SuppressedError.prototype` is %SuppressedError.prototype%.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-suppressederror-prototype-objects">
        <h1>Properties of the SuppressedError Prototype Object</h1>
        <p>The <dfn>SuppressedError prototype object</dfn>:</p>
        <ul>
          <li>is <dfn>%SuppressedError.prototype%</dfn>.</li>
          <li>is an ordinary object.</li>
          <li>is not an Error instance or a SuppressedError instance and does not have an [[ErrorData]] internal slot.</li>
          <li>has a [[Prototype]] internal slot whose value is %Error.prototype%.</li>
        </ul>

        <emu-clause id="sec-suppressederror.prototype.constructor">
          <h1>SuppressedError.prototype.constructor</h1>
          <p>The initial value of `SuppressedError.prototype.constructor` is %SuppressedError%.</p>
        </emu-clause>

        <emu-clause id="sec-suppressederror.prototype.message">
          <h1>SuppressedError.prototype.message</h1>
          <p>The initial value of `SuppressedError.prototype.message` is the empty String.</p>
        </emu-clause>

        <emu-clause id="sec-suppressederror.prototype.name">
          <h1>SuppressedError.prototype.name</h1>
          <p>The initial value of `SuppressedError.prototype.name` is *"SuppressedError"*.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-suppressederror-instances">
        <h1>Properties of SuppressedError Instances</h1>
        <p>SuppressedError instances are ordinary objects that inherit properties from their SuppressedError prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) to identify Error, AggregateError, SuppressedError, or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>
    </ins>

  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-%iteratorprototype%-object">
      <h1>The %IteratorPrototype% Object</h1>

      <ins class="block">
      <emu-clause id="sec-%iteratorprototype%-@@dispose">
        <h1>%IteratorPrototype% [ @@dispose ] ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _return_ be ? GetMethod(_O_, `"return"`).
          1. If _return_ is not *undefined*, then
            1. Perform ? Call(_return_, _O_, « »).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.dispose]"*.</p>
      </emu-clause>
      </ins>
    </emu-clause>

    <emu-clause id="sec-%asynciteratorprototype%-object">
      <h1>The %AsyncIteratorPrototype% Object</h1>

      <ins class="block">
      <emu-clause id="sec-%asynciteratorprototype%-@@asyncdispose">
        <h1>%AsyncIteratorPrototype% [ @@asyncDispose ] ( )</h1>
        <p>The method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _return_ be GetMethod(_O_, `"return"`).
          1. IfAbruptRejectPromise(_return_, _promiseCapability_).
          1. If _return_ is *undefined*, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
          1. Else,
            1. Let _result_ be Call(_return_, _O_, « *undefined* »).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. Let _resultWrapper_ be Completion(PromiseResolve(%Promise%, _result_)).
            1. IfAbruptRejectPromise(_resultWrapper_, _promiseCapability_).
            1. Let _unwrap_ be a new Abstract Closure that performs the following steps when called:
              1. Return *undefined*.
            1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, "", « »).
            1. Perform PerformPromiseThen(_resultWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.asyncDispose]"*.</p>
      </emu-clause>
      </ins>
    </emu-clause>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-resource-management">
    <h1>Resource Management</h1>

    <emu-clause id="sec-common-resource-management-interfaces">
      <h1>Common Resource Management Interfaces</h1>

      <emu-clause id="sec-disposable-interface">
        <h1>The <i>Disposable</i> Interface</h1>
        <p>The <i>Disposable</i> interface includes the property described in <emu-xref href="#table-disposable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-disposable-interface-required-properties" caption="&lt;em&gt;Disposable&lt;/em&gt; Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `@@dispose`
              </td>
              <td>
                a function
              </td>
              <td>
                <p>Invoking this method notifies the <i>Disposable</i> object that the caller does not intend to continue to use this object. This method should perform any necessary logic to perform explicit clean-up of the resource including, but not limited to, file system handles, streams, host objects, etc. When an exception is thrown from this method, it typically means that the resource could not be explicitly freed.</p>
                <p>If called more than once on the same object, the function should not throw an exception. However, this requirement is not enforced.</p>
                <p>When using a <i>Disposable</i> object, it is good practice to create the instance with a `using` declaration, as the resource will be automatically disposed when the |Block| or |Module| immediately containing the declaration has been evaluated.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncdisposable-interface">
        <h1>The <i>AsyncDisposable</i> Interface</h1>
        <p>The <i>AsyncDisposable</i> interface includes the property described in <emu-xref href="#table-asyncdisposable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-asyncdisposable-interface-required-properties" caption="&lt;em&gt;AsyncDisposable&lt;/em&gt; Interface Required Properties">
          <table>
            <tbody>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Requirements
              </th>
            </tr>
            <tr>
              <td>
                `@@asyncDispose`
              </td>
              <td>
                a function that returns a promise
              </td>
              <td>
                <p>Invoking this method notifies the <i>AsyncDisposable</i> object that the caller does not intend to continue to use this object. This method should perform any necessary logic to perform explicit clean-up of the resource including, but not limited to, file system handles, streams, host objects, etc. When an exception is thrown from this method, it typically means that the resource could not be explicitly freed. An <i>AsyncDisposable</i> object is not considered "disposed" until the resulting Promise has been fulfilled.</p>
                <p>If called more than once on the same object, the function should not throw an exception. However, this requirement is not enforced.</p>
                <p>When using an <i>AsyncDisposable</i> object, it is good practice to create the instance with a `await using` declaration, as the resource will be automatically disposed when the |Block| or |Module| immediately containing the declaration has been evaluated.</p>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  </ins>

  <ins class="block">
  <emu-clause id="sec-disposablestack-objects">
    <h1>DisposableStack Objects</h1>
    <p>A DisposableStack is an object that can be used to contain one or more resources that should be disposed together.</p>
    <p>Any DisposableStack object is in one of two mutually exclusive states: <em>disposed</em> or <em>pending</em>:</p>
    <ul>
      <li>A disposable stack `d` is pending if `d[Symbol.dispose]()` has yet to be invoked for `d`.</li>
      <li>A disposable stack `d` is disposed if `d[Symbol.dispose]()` has already been invoked once for `d`.</li>
    </ul>

    <emu-clause id="sec-disposablestack-constructor">
      <h1>The DisposableStack Constructor</h1>
      <p>The DisposableStack constructor:</p>
      <ul>
        <li>is <dfn>%DisposableStack%</dfn>.</li>
        <li>is the initial value of the *"DisposableStack"* property of the global object.</li>
        <li>creates and initializes a new DisposableStack when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified DisposableStack behaviour must include a `super` call to the DisposableStack constructor to create and initialize the subclass instance with the internal state necessary to support the `DisposableStack` and `DisposableStack.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-disposablestack">
        <h1>DisposableStack ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _disposableStack_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DisposableStack.prototype%"*, « [[DisposableState]], [[DisposeCapability]] »).
          1. Set _disposableStack_.[[DisposableState]] to ~pending~.
          1. Set _disposableStack_.[[DisposeCapability]] to NewDisposeCapability().
          1. Return _disposableStack_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-disposablestack-constructor">
      <h1>Properties of the DisposableStack Constructor</h1>
      <p>The DisposableStack constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-disposablestack.prototype">
        <h1>DisposableStack.prototype</h1>
        <p>The initial value of `DisposableStack.prototype` is the DisposableStack prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-disposablestack-prototype-object">
      <h1>Properties of the DisposableStack Prototype Object</h1>
      <p>The <dfn>DisposableStack prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%DisposableStack.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[DisposableState]] internal slot or any of the other internal slots of DisposableStack instances.</li>
      </ul>

      <emu-clause id="sec-disposablestack.prototype.adopt">
        <h1>DisposableStack.prototype.adopt( _value_, _onDispose_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If IsCallable(_onDispose_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _value_ and _onDispose_ and performs the following steps when called:
            1. Return ? Call(_onDispose_, *undefined*, &laquo; _value_ &raquo;).
          1. Let _F_ be CreateBuiltinFunction(_closure_, 0, *""*, « »).
          1. Perform ? AddDisposableResource(_disposableStack_.[[DisposeCapability]], *undefined*, ~sync-dispose~, _F_).
          1. Return _value_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.defer">
        <h1>DisposableStack.prototype.defer( _onDispose_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If IsCallable(_onDispose_) is *false*, throw a *TypeError* exception.
          1. Perform ? AddDisposableResource(_disposableStack_.[[DisposeCapability]], *undefined*, ~sync-dispose~, _onDispose_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.dispose">
        <h1>DisposableStack.prototype.dispose ()</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, return *undefined*.
          1. Set _disposableStack_.[[DisposableState]] to ~disposed~.
          1. Return DisposeResources(_disposableStack_.[[DisposeCapability]], NormalCompletion(*undefined*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-disposablestack.prototype.disposed">
        <h1>get DisposableStack.prototype.disposed</h1>
        <p>`DisposableStack.prototype.disposed` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.move">
        <h1>DisposableStack.prototype.move()</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. Let _newDisposableStack_ be ? OrdinaryCreateFromConstructor(%DisposableStack%, *"%DisposableStack.prototype%"*, « [[DisposableState]], [[DisposeCapability]] »).
          1. Set _newDisposableStack_.[[DisposableState]] to ~pending~.
          1. Set _newDisposableStack_.[[DisposeCapability]] to _disposableStack_.[[DisposeCapability]].
          1. Set _disposableStack_.[[DisposeCapability]] to NewDisposeCapability().
          1. Set _disposableStack_.[[DisposableState]] to ~disposed~.
          1. Return _newDisposableStack_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype.use">
        <h1>DisposableStack.prototype.use( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _disposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_disposableStack_, [[DisposableState]]).
          1. If _disposableStack_.[[DisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. Perform ? AddDisposableResource(_disposableStack_.[[DisposeCapability]], _value_, ~sync-dispose~).
          1. Return _value_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype-@@dispose">
        <h1>DisposableStack.prototype [ @@dispose ] ()</h1>
        <p>The initial value of the @@dispose property is %DisposableStack.prototype.dispose%, defined in <emu-xref href="#sec-disposablestack.prototype.dispose"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-disposablestack.prototype-@@toStringTag">
        <h1>DisposableStack.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the `@@toStringTag` property is the String value *"DisposableStack"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-disposablestack-instances">
      <h1>Properties of DisposableStack Instances</h1>
      <p>DisposableStack instances are ordinary objects that inherit properties from the DisposableStack prototype object (the intrinsic %DisposableStack.prototype%). DisposableStack instances are initially created with internal slots described in <emu-xref href="#table-internal-slots-of-disposablestack-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-disposablestack-instances" caption="Internal Slots of DisposableStack Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[DisposableState]]
            </td>
            <td>
              ~pending~ or ~disposed~.
            </td>
            <td>
              Governs how a disposable stack will react to incoming calls to its `@@dispose` method.
            </td>
          </tr>
          <tr>
            <td>
              [[DisposeCapability]]
            </td>
            <td>
              a DisposeCapability Record
            </td>
            <td>
              Holds the stack of disposable resources.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncdisposablestack-objects">
    <h1>AsyncDisposableStack Objects</h1>
    <p>An AsyncDisposableStack is an object that can be used to contain one or more resources that should be asynchronously disposed together.</p>
    <p>Any AsyncDisposableStack object is in one of two mutually exclusive states: <em>disposed</em> or <em>pending</em>:</p>
    <ul>
      <li>An async-disposable stack `d` is pending if `d[Symbol.asyncDispose]()` has yet to be invoked for `d`.</li>
      <li>An async-disposable stack `d` is disposed if `d[Symbol.asyncDispose]()` has already been invoked once for `d`.</li>
    </ul>

    <emu-clause id="sec-asyncdisposablestack-constructor">
      <h1>The AsyncDisposableStack Constructor</h1>
      <p>The AsyncDisposableStack constructor:</p>
      <ul>
        <li>is <dfn>%AsyncDisposableStack%</dfn>.</li>
        <li>is the initial value of the *"AsyncDisposableStack"* property of the global object.</li>
        <li>creates and initializes a new AsyncDisposableStack when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncDisposableStack behaviour must include a `super` call to the AsyncDisposableStack constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncDisposableStack` and `AsyncDisposableStack.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asyncdisposablestack">
        <h1>AsyncDisposableStack ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _asyncDisposableStack_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncDisposableStack.prototype%"*, « [[AsyncDisposableState]], [[DisposeCapability]] »).
          1. Set _asyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
          1. Set _asyncDisposableStack_.[[DisposeCapability]] to NewDisposeCapability().
          1. Return _asyncDisposableStack_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asyncdisposablestack-constructor">
      <h1>Properties of the AsyncDisposableStack Constructor</h1>
      <p>The AsyncDisposableStack constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>
      <emu-clause id="sec-asyncdisposablestack.prototype">
        <h1>AsyncDisposableStack.prototype</h1>
        <p>The initial value of `AsyncDisposableStack.prototype` is the AsyncDisposableStack prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asyncdisposablestack-prototype-object">
      <h1>Properties of the AsyncDisposableStack Prototype Object</h1>
      <p>The <dfn>AsyncDisposableStack prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncDisposableStack.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[AsyncDisposableState]] internal slot or any of the other internal slots of AsyncDisposableStack instances.</li>
      </ul>

      <emu-clause id="sec-asyncdisposablestack.prototype.adopt">
        <h1>AsyncDisposableStack.prototype.adopt( _value_, _onDisposeAsync_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If IsCallable(_onDisposeAsync_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _value_ and _onDisposeAsync_ and performs the following steps when called:
            1. Return ? Call(_onDisposeAsync_, *undefined*, « _value_ »).
          1. Let _F_ be CreateBuiltinFunction(_closure_, 0, *""*, « »).
          1. Perform ? AddDisposableResource(_asyncDisposableStack_.[[DisposeCapability]], *undefined*, ~async-dispose~, _F_).
          1. Return _value_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.defer">
        <h1>AsyncDisposableStack.prototype.defer( _onDisposeAsync_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. If IsCallable(_onDisposeAsync_) is *false*, throw a *TypeError* exception.
          1. Perform ? AddDisposableResource(_asyncDisposableStack_.[[DisposeCapability]], *undefined*, ~async-dispose~, _onDisposeAsync_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.disposeAsync">
        <h1>AsyncDisposableStack.prototype.disposeAsync()</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. If _asyncDisposableStack_ does not have an [[AsyncDisposableState]] internal slot, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
            1. Return _promiseCapability_.[[Promise]].
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
            1. Return _promiseCapability_.[[Promise]].
          1. Set _asyncDisposableStack_.[[AsyncDisposableState]] to ~disposed~.
          1. Let _result_ be DisposeResources(_asyncDisposableStack_.[[DisposeCapability]], NormalCompletion(*undefined*)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_ »).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-asyncdisposablestack.prototype.disposed">
        <h1>get AsyncDisposableStack.prototype.disposed</h1>
        <p>`AsyncDisposableStack.prototype.disposed` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.move">
        <h1>AsyncDisposableStack.prototype.move()</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. Let _newAsyncDisposableStack_ be ? OrdinaryCreateFromConstructor(%AsyncDisposableStack%, *"%AsyncDisposableStack.prototype%"*, « [[AsyncDisposableState]], [[DisposeCapability]] »).
          1. Set _newAsyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
          1. Set _newAsyncDisposableStack_.[[DisposeCapability]] to _asyncDisposableStack_.[[DisposeCapability]].
          1. Set _asyncDisposableStack_.[[DisposeCapability]] to NewDisposeCapability().
          1. Set _asyncDisposableStack_.[[AsyncDisposableState]] to ~disposed~.
          1. Return _newAsyncDisposableStack_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype.use">
        <h1>AsyncDisposableStack.prototype.use( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncDisposableStack_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
          1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
          1. Perform ? AddDisposableResource(_asyncDisposableStack_.[[DisposeCapability]], _value_, ~async-dispose~).
          1. Return _value_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype-@@asyncDispose">
        <h1>AsyncDisposableStack.prototype [ @@asyncDispose ] ()</h1>
        <p>The initial value of the @@asyncDispose property is %AsyncDisposableStack.prototype.disposeAsync%, defined in <emu-xref href="#sec-asyncdisposablestack.prototype.disposeAsync"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-asyncdisposablestack.prototype-@@toStringTag">
        <h1>AsyncDisposableStack.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the `@@toStringTag` property is the String value *"AsyncDisposableStack"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncdisposablestack-instances">
      <h1>Properties of AsyncDisposableStack Instances</h1>
      <p>AsyncDisposableStack instances are ordinary objects that inherit properties from the AsyncDisposableStack prototype object (the intrinsic %AsyncDisposableStack.prototype%). AsyncDisposableStack instances are initially created with internal slots described in <emu-xref href="#table-internal-slots-of-asyncdisposablestack-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-asyncdisposablestack-instances" caption="Internal Slots of AsyncDisposableStack Instances">
        <table>
          <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncDisposableState]]
            </td>
            <td>
              ~pending~ or ~disposed~
            </td>
            <td>
              Governs how an async disposable stack will react to incoming calls to its `@@asyncDispose` method.
            </td>
          </tr>
          <tr>
            <td>
              [[DisposeCapability]]
            </td>
            <td>
              a DisposeCapability Record
            </td>
            <td>
              Resources to be disposed when the disposable stack is disposed.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>Additional ECMAScript Features for Web Browsers</h1>

  <emu-annex id="sec-other-additional-features">
    <h1>Other Additional Features</h1>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>Block-Level Function Declarations Web Legacy Compatibility Semantics</h1>

      <emu-annex id="sec-web-compat-blockdeclarationinstantiation">
        <h1>Changes to BlockDeclarationInstantiation</h1>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref>:</p>
        <emu-alg replaces-step="step-blockdeclarationinstantiation-createmutablebinding">
          1. If _env_.HasBinding(_dn_) is *false*, then
            1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
        </emu-alg>
        <p>During BlockDeclarationInstantiation the following steps are performed in place of step <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref>:</p>
        <emu-alg replaces-step="step-blockdeclarationinstantiation-initializebinding">
          1. Perform the following steps:
            1. If the binding for _fn_ in _env_ is an uninitialized binding, then
              1. Perform ! _env_.InitializeBinding(_fn_, _fo_<ins>, ~normal~</ins>).
            1. Else,
              1. Assert: _d_ is a |FunctionDeclaration|.
              1. Perform ! _env_.SetMutableBinding(_fn_, _fo_, *false*).
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>
</emu-annex>
