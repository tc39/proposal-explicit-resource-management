<ins class="block">
<emu-clause id="sec-asyncdisposablestack-objects">
  <h1>AsyncDisposableStack Objects</h1>
  <p>An AsyncDisposableStack is an object that can be used to contain one or more resources that should be asynchronously disposed together.</p>
  <p>Any AsyncDisposableStack object is in one of two mutually exclusive states: <em>disposed</em> or <em>pending</em>:</p>
  <ul>
    <li>An async-disposable stack `d` is pending if `d[Symbol.asyncDispose]()` has yet to be invoked for `d`.</li>
    <li>An async-disposable stack `d` is disposed if `d[Symbol.asyncDispose]()` has already been invoked once for `d`.</li>
  </ul>

  <emu-clause id="sec-asyncdisposablestack-constructor">
    <h1>The AsyncDisposableStack Constructor</h1>
    <p>The AsyncDisposableStack constructor:</p>
    <ul>
      <li>is <dfn>%AsyncDisposableStack%</dfn>.</li>
      <li>is the initial value of the *"AsyncDisposableStack"* property of the global object.</li>
      <li>creates and initializes a new AsyncDisposableStack when called as a constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncDisposableStack behaviour must include a `super` call to the AsyncDisposableStack constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncDisposableStack` and `AsyncDisposableStack.prototype` built-in methods.</li>
    </ul>
    <emu-clause id="sec-asyncdisposablestack">
      <h1>AsyncDisposableStack ( )</h1>
      <p>When the `AsyncDisposableStack` function is called, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _asyncDisposableStack_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncDisposableStack.prototype%"*, &laquo; [[AsyncDisposableState]], [[DisposableResourceStack]], [[BoundDisposeAsync]] &raquo;).
        1. Set _asyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
        1. Set _asyncDisposableStack_.[[DisposableResourceStack]] to a new empty List.
        1. Set _asyncDisposableStack_.[[BoundDisposeAsync]] to *undefined*.
        1. Return _asyncDisposableStack_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-asyncdisposablestack-constructor">
    <h1>Properties of the AsyncDisposableStack Constructor</h1>
    <p>The AsyncDisposableStack constructor:</p>
    <ul>
      <li>Has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
    </ul>

    <!--
    NOTE: If we decide not to support @@species, the following clause should be removed:
    -->
    <emu-clause id="sec-get-asyncdisposablestack-@@species">
      <h1>get AsyncDisposableStack [ @@species ]</h1>
      <p>`AsyncDisposableStack[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>
      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-asyncdisposablestack-prototype-object">
    <h1>Properties of the AsyncDisposableStack Prototype Object</h1>
    <p>The <dfn>AsyncDisposableStack prototype object</dfn>:</p>
    <ul>
      <li>is <dfn>%AsyncDisposableStack.prototype%</dfn>.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is an ordinary object.</li>
      <li>does not have an [[AsyncDisposableState]] internal slot or any of the other internal slots of AsyncDisposableStack instances.</li>
    </ul>

    <emu-clause id="sec-get-asyncdisposablestack.prototype.disposeAsync">
      <h1>get AsyncDisposableStack.prototype.disposeAsync</h1>
      <p>`AsyncDisposableStack.prototype.disposeAsync` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _asyncDisposableStack_ be the *this* value.
        1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
        1. If _asyncDisposableStack_.[[BoundDisposeAsync]] is *undefined*, then
          1. Let _disposeAsync_ be GetMethod(_asyncDisposableStack_, @@asyncDispose).
          1. If _disposeAsync_ is *undefined*, throw a *TypeError* exception.
          1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-asyncdisposablestack-dispose-functions"></emu-xref>.
          1. Set _F_.[[AsyncDisposableStack]] to _asyncDisposableStack_.
          1. Set _F_.[[DisposeAsyncMethod]] to _disposeAsync_.
          1. Set _asyncDisposableStack_.[[BoundDisposeAsync]] to _F_.
        1. Return _asyncDisposableStack_.[[BoundDisposeAsync]].
      </emu-alg>

      <emu-clause id="sec-asyncdisposablestack-dispose-functions">
        <h1>AsyncDisposableStack Dispose Functions</h1>
        <p>An AsyncDisposableStack dispose function is an anonymous built-in function that has [[AsyncDisposableStack]] and [[DisposeAsyncMethod]] internal slots.</p>
        <p>When an AsyncDisposableStack dispose function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _F_ be the active function object.
          1. Let _asyncDisposableStack_ be _F_.[[AsyncDisposableStack]].
          1. Let _disposeAsync_ be _F_.[[DisposeAsyncMethod]].
          1. Assert: Type(_asyncDisposableStack_) is Object and _asyncDisposableStack_ has an [[AsyncDisposableState]] internal slot.
          1. Assert: IsCallable(_disposeAsync_) is *true*.
          1. Return Call(_disposeAsync_, _asyncDisposableStack_, &laquo; &raquo;).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncdisposablestack.prototype.use">
      <h1>AsyncDisposableStack.prototype.use( _value_ [, _onDisposeAsync_ ] )</h1>
      <p>When the `use` function is called with one or two arguments, the following steps are taken:</p>
      <emu-note>
        <p>The _onDisposeAsync_ argument is optional. If it is not provided, *undefined* is used.</p>
      </emu-note>
      <emu-alg>
        1. Let _asyncDisposableStack_ be the *this* value.
        1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
        1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
        1. If _onDisposeAsync_ is not *undefined*, then
          1. If IsCallable(_onDisposeAsync_) is *false*, throw a *TypeError* exception.
          1. Let _F_ be a new built-in function object as defined in <emu-xref href="#sec-asyncdisposablestack-callback-functions"></emu-xref>.
          1. Set _F_.[[Argument]] to _value_.
          1. Set _F_.[[OnDisposeAsyncCallback]] to _onDisposeAsync_.
          1. Perform ? AddDisposableResource(_asyncDisposableStack_, *undefined*, ~async-dispose~, _F_).
        1. Else, if _value_ is neither *null* nor *undefined*, then
          1. If Type(_value_) is not Object, throw a *TypeError* exception.
          1. Let _method_ be GetDisposeMethod(_value_, ~async-dispose~).
          1. If _method_ is *undefined*, then
            1. If IsCallable(_value_) is *true*, then
              1. Perform ? AddDisposableResource(_disposableStack_, *undefined*, ~async-dispose~, _value_).
            1. Else,
              1. Throw a *TypeError* exception.
          1. Else,
            1. Perform ? AddDisposableResource(_disposableStack_, _value_, ~async-dispose~, _method_).
        1. Return _value_.
      </emu-alg>

      <emu-clause id="sec-asyncdisposablestack-callback-functions">
        <h1>AsyncDisposableStack Callback Functions</h1>
        <p>An AsyncDisposableStack callback function is an anonymous built-in function that has [[Argument]] and [[OnDisposeAsyncCallback]] internal slots.</p>
        <p>When an AsyncDisposableStack callback function is called, the following steps are taken:</p>
        <emu-alg>
          1. Let _F_ be the active function object.
          1. Assert: IsCallable(_F_.[[OnDisposeAsyncCallback]]) is *true*.
          1. Return Call(_F_.[[OnDisposeAsyncCallback]], *undefined*, &laquo; _F_.[[Argument]] &raquo;).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncdisposablestack.prototype.move">
      <h1>AsyncDisposableStack.prototype.move()</h1>
      <p>When the `move` function is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _asyncDisposableStack_ be the *this* value.
        1. Perform ? RequireInternalSlot(_asyncDisposableStack_, [[AsyncDisposableState]]).
        1. If _asyncDisposableStack_.[[AsyncDisposableState]] is ~disposed~, throw a *ReferenceError* exception.
        <!--
        NOTE: If we decide not to support @@species, the following steps should be removed:
        -->
        1. Let _C_ be ? SpeciesConstructor(_asyncDisposableStack_, %AsyncDisposableStack%).
        1. Assert: IsConstructor(_C_) is *true*.
        1. Let _newAsyncDisposableStack_ be ? Construct(_C_, &laquo; &raquo;).
        1. Perform ? RequireInternalSlot(_newAsyncDisposableStack_, [[AsyncDisposableState]]).
        1. If _newAsyncDisposableStack_.[[AsyncDisposableState]] is not ~pending~, throw a *TypeError* exception.
        1. Append each element of _asyncDisposableStack_.[[DisposableResourceStack]] to _newAsyncDisposableStack_.[[DisposableResourceStack]].
        <!--
        NOTE: If we decide not to support @@species, we can use these steps instead:

        1. Let _newAsyncDisposableStack_ be ? OrdinaryCreateFromConstructor(%AsyncDisposableStack, *"%AsyncDisposableStack.prototype%"*, &laquo; [[AsyncDisposableState]], [[DisposableResourceStack]], [[BoundDisposeAsync]] &raquo;).
        1. Set _newAsyncDisposableStack_.[[AsyncDisposableState]] to ~pending~.
        1. Set _newAsyncDisposableStack_.[[DisposableResourceStack]] to _asyncDisposableStack_.[[DisposableResourceStack]].
        1. Set _newAsyncDisposableStack_.[[BoundDisposeAsync]] to *undefined*.
        -->
        1. Set _asyncDisposableStack_.[[DisposableResourceStack]] to a new empty List.
        1. Return _newAsyncDisposableStack_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncdisposablestack.prototype-@@asyncDispose">
      <h1>AsyncDisposableStack.prototype [ @@asyncDispose ] ()</h1>
      <p>When the `@@asyncDispose` method is called, the following steps are taken:</p>
      <emu-alg>
        1. Let _asyncDisposableStack_ be the *this* value.
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. If _asyncDisposableStack_ does not have a [[DisposableState]] internal slot, then
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
          1. Return _promiseCapability_.[[Promise]].
        1. If _asyncDisposableStack_.[[DisposableState]] is ~disposed~, then
          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
          1. Return _promiseCapability_.[[Promise]].
        1. Set _asyncDisposableStack_.[[DisposableState]] to ~disposed~.
        1. Let _result_ be DisposeResources(_asyncDisposableStack_, NormalCompletion(*undefined*)).
        1. IfAbruptRejectPromise(_result_, _promiseCapability_).
        1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_ &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asyncdisposablestack.prototype-@@toStringTag">
      <h1>AsyncDisposableStack.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the `@@toStringTag` property is the String value *"AsyncDisposableStack"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-asyncdisposablestack-instances">
    <h1>Properties of AsyncDisposableStack Instances</h1>
    <p>AsyncDisposableStack instances are ordinary objects that inherit properties from the AsyncDisposableStack prototype object (the intrinsic %AsyncDisposableStack.prototype%). AsyncDisposableStack instances are initially created with internal slots described in <emu-xref href="#table-internal-slots-of-asyncdisposablestack-instances"></emu-xref>.</p>
    <emu-table id="table-internal-slots-of-asyncdisposablestack-instances" caption="Internal Slots of AsyncDisposableStack Instances">
      <table>
        <tbody>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[AsyncDisposableState]]
          </td>
          <td>
            One of ~pending~ or ~disposed~. Governs how a disposable stack will react to incoming calls to its `@@asyncDispose` method.
          </td>
        </tr>
        <tr>
          <td>
            [[DisposableResourceStack]]
          </td>
          <td>
            A List of DisposableResource records.
          </td>
        </tr>
        <tr>
          <td>
            [[BoundDisposeAsync]]
          </td>
          <td>
            Either *undefined* or a function object that caches the function returned by the `AsyncDisposableStack.prototype.disposeAsync` accessor (<emu-xref href="#sec-get-asyncdisposablestack.prototype.disposeAsync"></emu-xref>).
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>
</ins>